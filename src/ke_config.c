/**
 ******************************************************************************
 *
 * Copyright (c) 2025 KaiserEngineering, LLC
 * Author Matthew Kaiser
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 ******************************************************************************
 */

#include "ke_config.h"

#define DEFAULT_VIEW_ENABLE VIEW_STATE_DISABLED
#define DEFAULT_VIEW_NUM_GAUGES 0
#define DEFAULT_VIEW_BACKGROUND VIEW_BACKGROUND_BLACK
#define DEFAULT_VIEW_GAUGE_THEME GAUGE_THEME_STOCK_ST
#define DEFAULT_VIEW_GAUGE_PID 0
#define DEFAULT_VIEW_GAUGE_UNITS PID_UNITS_RESERVED
#define DEFAULT_ALERT_ENABLE ALERT_STATE_DISABLED
#define DEFAULT_ALERT_MESSAGE 0
#define DEFAULT_ALERT_COMPARE ALERT_COMPARISON_GREATER_THAN
#define DEFAULT_ALERT_THRESHOLD 0
#define DEFAULT_DYNAMIC_ENABLE DYNAMIC_STATE_DISABLED
#define DEFAULT_DYNAMIC_PRIORITY DYNAMIC_PRIORITY_LOW
#define DEFAULT_DYNAMIC_COMPARE DYNAMIC_COMPARISON_GREATER_THAN
#define DEFAULT_DYNAMIC_THRESHOLD 0
#define DEFAULT_DYNAMIC_INDEX 0

// EEPROM Memory Map - view enable
#define EEPROM_VIEW_ENABLE1_BYTE1 (uint16_t)0x0000
#define EEPROM_VIEW_ENABLE2_BYTE1 (uint16_t)0x0001
#define EEPROM_VIEW_ENABLE3_BYTE1 (uint16_t)0x0002
static const uint16_t map_view_enable_byte1[MAX_VIEWS] = {
    EEPROM_VIEW_ENABLE1_BYTE1,
    EEPROM_VIEW_ENABLE2_BYTE1,
    EEPROM_VIEW_ENABLE3_BYTE1
    };

// EEPROM Memory Map - view num_gauges
#define EEPROM_VIEW_NUM_GAUGES1_BYTE1 (uint16_t)0x0003
#define EEPROM_VIEW_NUM_GAUGES2_BYTE1 (uint16_t)0x0004
#define EEPROM_VIEW_NUM_GAUGES3_BYTE1 (uint16_t)0x0005
static const uint16_t map_view_num_gauges_byte1[GAUGES_PER_VIEW] = {
    EEPROM_VIEW_NUM_GAUGES1_BYTE1,
    EEPROM_VIEW_NUM_GAUGES2_BYTE1,
    EEPROM_VIEW_NUM_GAUGES3_BYTE1
    };

// EEPROM Memory Map - view background
#define EEPROM_VIEW_BACKGROUND1_BYTE1 (uint16_t)0x0006
#define EEPROM_VIEW_BACKGROUND2_BYTE1 (uint16_t)0x0007
#define EEPROM_VIEW_BACKGROUND3_BYTE1 (uint16_t)0x0008
static const uint16_t map_view_background_byte1[MAX_VIEWS] = {
    EEPROM_VIEW_BACKGROUND1_BYTE1,
    EEPROM_VIEW_BACKGROUND2_BYTE1,
    EEPROM_VIEW_BACKGROUND3_BYTE1
    };

// EEPROM Memory Map - view_gauge theme
#define EEPROM_VIEW1_GAUGE_THEME1_BYTE1 (uint16_t)0x0009
#define EEPROM_VIEW1_GAUGE_THEME2_BYTE1 (uint16_t)0x000A
#define EEPROM_VIEW1_GAUGE_THEME3_BYTE1 (uint16_t)0x000B
#define EEPROM_VIEW2_GAUGE_THEME1_BYTE1 (uint16_t)0x000C
#define EEPROM_VIEW2_GAUGE_THEME2_BYTE1 (uint16_t)0x000D
#define EEPROM_VIEW2_GAUGE_THEME3_BYTE1 (uint16_t)0x000E
#define EEPROM_VIEW3_GAUGE_THEME1_BYTE1 (uint16_t)0x000F
#define EEPROM_VIEW3_GAUGE_THEME2_BYTE1 (uint16_t)0x0010
#define EEPROM_VIEW3_GAUGE_THEME3_BYTE1 (uint16_t)0x0011
#define EEPROM_VIEW1_GAUGE_THEME_BYTE1 {EEPROM_VIEW1_GAUGE_THEME1_BYTE1, EEPROM_VIEW1_GAUGE_THEME2_BYTE1, EEPROM_VIEW1_GAUGE_THEME3_BYTE1}
#define EEPROM_VIEW2_GAUGE_THEME_BYTE1 {EEPROM_VIEW2_GAUGE_THEME1_BYTE1, EEPROM_VIEW2_GAUGE_THEME2_BYTE1, EEPROM_VIEW2_GAUGE_THEME3_BYTE1}
#define EEPROM_VIEW3_GAUGE_THEME_BYTE1 {EEPROM_VIEW3_GAUGE_THEME1_BYTE1, EEPROM_VIEW3_GAUGE_THEME2_BYTE1, EEPROM_VIEW3_GAUGE_THEME3_BYTE1}
static const uint16_t map_view_gauge_theme_byte1[MAX_VIEWS][GAUGES_PER_VIEW] = {
    EEPROM_VIEW1_GAUGE_THEME_BYTE1,
    EEPROM_VIEW2_GAUGE_THEME_BYTE1,
    EEPROM_VIEW3_GAUGE_THEME_BYTE1
    };

// EEPROM Memory Map - view_gauge pid
#define EEPROM_VIEW1_GAUGE_PID1_BYTE1 (uint16_t)0x0012
#define EEPROM_VIEW1_GAUGE_PID1_BYTE2 (uint16_t)0x0013
#define EEPROM_VIEW1_GAUGE_PID1_BYTE3 (uint16_t)0x0014
#define EEPROM_VIEW1_GAUGE_PID1_BYTE4 (uint16_t)0x0015
#define EEPROM_VIEW1_GAUGE_PID2_BYTE1 (uint16_t)0x0016
#define EEPROM_VIEW1_GAUGE_PID2_BYTE2 (uint16_t)0x0017
#define EEPROM_VIEW1_GAUGE_PID2_BYTE3 (uint16_t)0x0018
#define EEPROM_VIEW1_GAUGE_PID2_BYTE4 (uint16_t)0x0019
#define EEPROM_VIEW1_GAUGE_PID3_BYTE1 (uint16_t)0x001A
#define EEPROM_VIEW1_GAUGE_PID3_BYTE2 (uint16_t)0x001B
#define EEPROM_VIEW1_GAUGE_PID3_BYTE3 (uint16_t)0x001C
#define EEPROM_VIEW1_GAUGE_PID3_BYTE4 (uint16_t)0x001D
#define EEPROM_VIEW2_GAUGE_PID1_BYTE1 (uint16_t)0x001E
#define EEPROM_VIEW2_GAUGE_PID1_BYTE2 (uint16_t)0x001F
#define EEPROM_VIEW2_GAUGE_PID1_BYTE3 (uint16_t)0x0100
#define EEPROM_VIEW2_GAUGE_PID1_BYTE4 (uint16_t)0x0101
#define EEPROM_VIEW2_GAUGE_PID2_BYTE1 (uint16_t)0x0102
#define EEPROM_VIEW2_GAUGE_PID2_BYTE2 (uint16_t)0x0103
#define EEPROM_VIEW2_GAUGE_PID2_BYTE3 (uint16_t)0x0104
#define EEPROM_VIEW2_GAUGE_PID2_BYTE4 (uint16_t)0x0105
#define EEPROM_VIEW2_GAUGE_PID3_BYTE1 (uint16_t)0x0106
#define EEPROM_VIEW2_GAUGE_PID3_BYTE2 (uint16_t)0x0107
#define EEPROM_VIEW2_GAUGE_PID3_BYTE3 (uint16_t)0x0108
#define EEPROM_VIEW2_GAUGE_PID3_BYTE4 (uint16_t)0x0109
#define EEPROM_VIEW3_GAUGE_PID1_BYTE1 (uint16_t)0x010A
#define EEPROM_VIEW3_GAUGE_PID1_BYTE2 (uint16_t)0x010B
#define EEPROM_VIEW3_GAUGE_PID1_BYTE3 (uint16_t)0x010C
#define EEPROM_VIEW3_GAUGE_PID1_BYTE4 (uint16_t)0x010D
#define EEPROM_VIEW3_GAUGE_PID2_BYTE1 (uint16_t)0x010E
#define EEPROM_VIEW3_GAUGE_PID2_BYTE2 (uint16_t)0x010F
#define EEPROM_VIEW3_GAUGE_PID2_BYTE3 (uint16_t)0x0110
#define EEPROM_VIEW3_GAUGE_PID2_BYTE4 (uint16_t)0x0111
#define EEPROM_VIEW3_GAUGE_PID3_BYTE1 (uint16_t)0x0112
#define EEPROM_VIEW3_GAUGE_PID3_BYTE2 (uint16_t)0x0113
#define EEPROM_VIEW3_GAUGE_PID3_BYTE3 (uint16_t)0x0114
#define EEPROM_VIEW3_GAUGE_PID3_BYTE4 (uint16_t)0x0115
#define EEPROM_VIEW1_GAUGE_PID_BYTE1 {EEPROM_VIEW1_GAUGE_PID1_BYTE1, EEPROM_VIEW1_GAUGE_PID2_BYTE1, EEPROM_VIEW1_GAUGE_PID3_BYTE1}
#define EEPROM_VIEW2_GAUGE_PID_BYTE1 {EEPROM_VIEW2_GAUGE_PID1_BYTE1, EEPROM_VIEW2_GAUGE_PID2_BYTE1, EEPROM_VIEW2_GAUGE_PID3_BYTE1}
#define EEPROM_VIEW3_GAUGE_PID_BYTE1 {EEPROM_VIEW3_GAUGE_PID1_BYTE1, EEPROM_VIEW3_GAUGE_PID2_BYTE1, EEPROM_VIEW3_GAUGE_PID3_BYTE1}
static const uint16_t map_view_gauge_pid_byte1[MAX_VIEWS][GAUGES_PER_VIEW] = {
    EEPROM_VIEW1_GAUGE_PID_BYTE1,
    EEPROM_VIEW2_GAUGE_PID_BYTE1,
    EEPROM_VIEW3_GAUGE_PID_BYTE1
    };

#define EEPROM_VIEW1_GAUGE_PID_BYTE2 {EEPROM_VIEW1_GAUGE_PID1_BYTE2, EEPROM_VIEW1_GAUGE_PID2_BYTE2, EEPROM_VIEW1_GAUGE_PID3_BYTE2}
#define EEPROM_VIEW2_GAUGE_PID_BYTE2 {EEPROM_VIEW2_GAUGE_PID1_BYTE2, EEPROM_VIEW2_GAUGE_PID2_BYTE2, EEPROM_VIEW2_GAUGE_PID3_BYTE2}
#define EEPROM_VIEW3_GAUGE_PID_BYTE2 {EEPROM_VIEW3_GAUGE_PID1_BYTE2, EEPROM_VIEW3_GAUGE_PID2_BYTE2, EEPROM_VIEW3_GAUGE_PID3_BYTE2}
static const uint16_t map_view_gauge_pid_byte2[MAX_VIEWS][GAUGES_PER_VIEW] = {
    EEPROM_VIEW1_GAUGE_PID_BYTE2,
    EEPROM_VIEW2_GAUGE_PID_BYTE2,
    EEPROM_VIEW3_GAUGE_PID_BYTE2
    };

#define EEPROM_VIEW1_GAUGE_PID_BYTE3 {EEPROM_VIEW1_GAUGE_PID1_BYTE3, EEPROM_VIEW1_GAUGE_PID2_BYTE3, EEPROM_VIEW1_GAUGE_PID3_BYTE3}
#define EEPROM_VIEW2_GAUGE_PID_BYTE3 {EEPROM_VIEW2_GAUGE_PID1_BYTE3, EEPROM_VIEW2_GAUGE_PID2_BYTE3, EEPROM_VIEW2_GAUGE_PID3_BYTE3}
#define EEPROM_VIEW3_GAUGE_PID_BYTE3 {EEPROM_VIEW3_GAUGE_PID1_BYTE3, EEPROM_VIEW3_GAUGE_PID2_BYTE3, EEPROM_VIEW3_GAUGE_PID3_BYTE3}
static const uint16_t map_view_gauge_pid_byte3[MAX_VIEWS][GAUGES_PER_VIEW] = {
    EEPROM_VIEW1_GAUGE_PID_BYTE3,
    EEPROM_VIEW2_GAUGE_PID_BYTE3,
    EEPROM_VIEW3_GAUGE_PID_BYTE3
    };

#define EEPROM_VIEW1_GAUGE_PID_BYTE4 {EEPROM_VIEW1_GAUGE_PID1_BYTE4, EEPROM_VIEW1_GAUGE_PID2_BYTE4, EEPROM_VIEW1_GAUGE_PID3_BYTE4}
#define EEPROM_VIEW2_GAUGE_PID_BYTE4 {EEPROM_VIEW2_GAUGE_PID1_BYTE4, EEPROM_VIEW2_GAUGE_PID2_BYTE4, EEPROM_VIEW2_GAUGE_PID3_BYTE4}
#define EEPROM_VIEW3_GAUGE_PID_BYTE4 {EEPROM_VIEW3_GAUGE_PID1_BYTE4, EEPROM_VIEW3_GAUGE_PID2_BYTE4, EEPROM_VIEW3_GAUGE_PID3_BYTE4}
static const uint16_t map_view_gauge_pid_byte4[MAX_VIEWS][GAUGES_PER_VIEW] = {
    EEPROM_VIEW1_GAUGE_PID_BYTE4,
    EEPROM_VIEW2_GAUGE_PID_BYTE4,
    EEPROM_VIEW3_GAUGE_PID_BYTE4
    };

// EEPROM Memory Map - view_gauge units
#define EEPROM_VIEW1_GAUGE_UNITS1_BYTE1 (uint16_t)0x0116
#define EEPROM_VIEW1_GAUGE_UNITS2_BYTE1 (uint16_t)0x0117
#define EEPROM_VIEW1_GAUGE_UNITS3_BYTE1 (uint16_t)0x0118
#define EEPROM_VIEW2_GAUGE_UNITS1_BYTE1 (uint16_t)0x0119
#define EEPROM_VIEW2_GAUGE_UNITS2_BYTE1 (uint16_t)0x011A
#define EEPROM_VIEW2_GAUGE_UNITS3_BYTE1 (uint16_t)0x011B
#define EEPROM_VIEW3_GAUGE_UNITS1_BYTE1 (uint16_t)0x011C
#define EEPROM_VIEW3_GAUGE_UNITS2_BYTE1 (uint16_t)0x011D
#define EEPROM_VIEW3_GAUGE_UNITS3_BYTE1 (uint16_t)0x011E
#define EEPROM_VIEW1_GAUGE_UNITS_BYTE1 {EEPROM_VIEW1_GAUGE_UNITS1_BYTE1, EEPROM_VIEW1_GAUGE_UNITS2_BYTE1, EEPROM_VIEW1_GAUGE_UNITS3_BYTE1}
#define EEPROM_VIEW2_GAUGE_UNITS_BYTE1 {EEPROM_VIEW2_GAUGE_UNITS1_BYTE1, EEPROM_VIEW2_GAUGE_UNITS2_BYTE1, EEPROM_VIEW2_GAUGE_UNITS3_BYTE1}
#define EEPROM_VIEW3_GAUGE_UNITS_BYTE1 {EEPROM_VIEW3_GAUGE_UNITS1_BYTE1, EEPROM_VIEW3_GAUGE_UNITS2_BYTE1, EEPROM_VIEW3_GAUGE_UNITS3_BYTE1}
static const uint16_t map_view_gauge_units_byte1[MAX_VIEWS][GAUGES_PER_VIEW] = {
    EEPROM_VIEW1_GAUGE_UNITS_BYTE1,
    EEPROM_VIEW2_GAUGE_UNITS_BYTE1,
    EEPROM_VIEW3_GAUGE_UNITS_BYTE1
    };

// EEPROM Memory Map - alert enable
#define EEPROM_ALERT_ENABLE1_BYTE1 (uint16_t)0x011F
#define EEPROM_ALERT_ENABLE2_BYTE1 (uint16_t)0x0200
#define EEPROM_ALERT_ENABLE3_BYTE1 (uint16_t)0x0201
#define EEPROM_ALERT_ENABLE4_BYTE1 (uint16_t)0x0202
#define EEPROM_ALERT_ENABLE5_BYTE1 (uint16_t)0x0203
static const uint16_t map_alert_enable_byte1[MAX_ALERTS] = {
    EEPROM_ALERT_ENABLE1_BYTE1,
    EEPROM_ALERT_ENABLE2_BYTE1,
    EEPROM_ALERT_ENABLE3_BYTE1,
    EEPROM_ALERT_ENABLE4_BYTE1,
    EEPROM_ALERT_ENABLE5_BYTE1
    };

// EEPROM Memory Map - alert message
#define EEPROM_ALERT_MESSAGE1_BYTE1 (uint16_t)0x0204
#define EEPROM_ALERT_MESSAGE1_BYTE2 (uint16_t)0x0205
#define EEPROM_ALERT_MESSAGE1_BYTE3 (uint16_t)0x0206
#define EEPROM_ALERT_MESSAGE1_BYTE4 (uint16_t)0x0207
#define EEPROM_ALERT_MESSAGE1_BYTE5 (uint16_t)0x0208
#define EEPROM_ALERT_MESSAGE1_BYTE6 (uint16_t)0x0209
#define EEPROM_ALERT_MESSAGE1_BYTE7 (uint16_t)0x020A
#define EEPROM_ALERT_MESSAGE1_BYTE8 (uint16_t)0x020B
#define EEPROM_ALERT_MESSAGE1_BYTE9 (uint16_t)0x020C
#define EEPROM_ALERT_MESSAGE1_BYTE10 (uint16_t)0x020D
#define EEPROM_ALERT_MESSAGE1_BYTE11 (uint16_t)0x020E
#define EEPROM_ALERT_MESSAGE1_BYTE12 (uint16_t)0x020F
#define EEPROM_ALERT_MESSAGE1_BYTE13 (uint16_t)0x0210
#define EEPROM_ALERT_MESSAGE1_BYTE14 (uint16_t)0x0211
#define EEPROM_ALERT_MESSAGE1_BYTE15 (uint16_t)0x0212
#define EEPROM_ALERT_MESSAGE1_BYTE16 (uint16_t)0x0213
#define EEPROM_ALERT_MESSAGE1_BYTE17 (uint16_t)0x0214
#define EEPROM_ALERT_MESSAGE1_BYTE18 (uint16_t)0x0215
#define EEPROM_ALERT_MESSAGE1_BYTE19 (uint16_t)0x0216
#define EEPROM_ALERT_MESSAGE1_BYTE20 (uint16_t)0x0217
#define EEPROM_ALERT_MESSAGE1_BYTE21 (uint16_t)0x0218
#define EEPROM_ALERT_MESSAGE1_BYTE22 (uint16_t)0x0219
#define EEPROM_ALERT_MESSAGE1_BYTE23 (uint16_t)0x021A
#define EEPROM_ALERT_MESSAGE1_BYTE24 (uint16_t)0x021B
#define EEPROM_ALERT_MESSAGE1_BYTE25 (uint16_t)0x021C
#define EEPROM_ALERT_MESSAGE1_BYTE26 (uint16_t)0x021D
#define EEPROM_ALERT_MESSAGE1_BYTE27 (uint16_t)0x021E
#define EEPROM_ALERT_MESSAGE1_BYTE28 (uint16_t)0x021F
#define EEPROM_ALERT_MESSAGE1_BYTE29 (uint16_t)0x0300
#define EEPROM_ALERT_MESSAGE1_BYTE30 (uint16_t)0x0301
#define EEPROM_ALERT_MESSAGE1_BYTE31 (uint16_t)0x0302
#define EEPROM_ALERT_MESSAGE1_BYTE32 (uint16_t)0x0303
#define EEPROM_ALERT_MESSAGE1_BYTE33 (uint16_t)0x0304
#define EEPROM_ALERT_MESSAGE1_BYTE34 (uint16_t)0x0305
#define EEPROM_ALERT_MESSAGE1_BYTE35 (uint16_t)0x0306
#define EEPROM_ALERT_MESSAGE1_BYTE36 (uint16_t)0x0307
#define EEPROM_ALERT_MESSAGE1_BYTE37 (uint16_t)0x0308
#define EEPROM_ALERT_MESSAGE1_BYTE38 (uint16_t)0x0309
#define EEPROM_ALERT_MESSAGE1_BYTE39 (uint16_t)0x030A
#define EEPROM_ALERT_MESSAGE1_BYTE40 (uint16_t)0x030B
#define EEPROM_ALERT_MESSAGE1_BYTE41 (uint16_t)0x030C
#define EEPROM_ALERT_MESSAGE1_BYTE42 (uint16_t)0x030D
#define EEPROM_ALERT_MESSAGE1_BYTE43 (uint16_t)0x030E
#define EEPROM_ALERT_MESSAGE1_BYTE44 (uint16_t)0x030F
#define EEPROM_ALERT_MESSAGE1_BYTE45 (uint16_t)0x0310
#define EEPROM_ALERT_MESSAGE1_BYTE46 (uint16_t)0x0311
#define EEPROM_ALERT_MESSAGE1_BYTE47 (uint16_t)0x0312
#define EEPROM_ALERT_MESSAGE1_BYTE48 (uint16_t)0x0313
#define EEPROM_ALERT_MESSAGE1_BYTE49 (uint16_t)0x0314
#define EEPROM_ALERT_MESSAGE1_BYTE50 (uint16_t)0x0315
#define EEPROM_ALERT_MESSAGE1_BYTE51 (uint16_t)0x0316
#define EEPROM_ALERT_MESSAGE1_BYTE52 (uint16_t)0x0317
#define EEPROM_ALERT_MESSAGE1_BYTE53 (uint16_t)0x0318
#define EEPROM_ALERT_MESSAGE1_BYTE54 (uint16_t)0x0319
#define EEPROM_ALERT_MESSAGE1_BYTE55 (uint16_t)0x031A
#define EEPROM_ALERT_MESSAGE1_BYTE56 (uint16_t)0x031B
#define EEPROM_ALERT_MESSAGE1_BYTE57 (uint16_t)0x031C
#define EEPROM_ALERT_MESSAGE1_BYTE58 (uint16_t)0x031D
#define EEPROM_ALERT_MESSAGE1_BYTE59 (uint16_t)0x031E
#define EEPROM_ALERT_MESSAGE1_BYTE60 (uint16_t)0x031F
#define EEPROM_ALERT_MESSAGE1_BYTE61 (uint16_t)0x0400
#define EEPROM_ALERT_MESSAGE1_BYTE62 (uint16_t)0x0401
#define EEPROM_ALERT_MESSAGE1_BYTE63 (uint16_t)0x0402
#define EEPROM_ALERT_MESSAGE1_BYTE64 (uint16_t)0x0403
#define EEPROM_ALERT_MESSAGE2_BYTE1 (uint16_t)0x0404
#define EEPROM_ALERT_MESSAGE2_BYTE2 (uint16_t)0x0405
#define EEPROM_ALERT_MESSAGE2_BYTE3 (uint16_t)0x0406
#define EEPROM_ALERT_MESSAGE2_BYTE4 (uint16_t)0x0407
#define EEPROM_ALERT_MESSAGE2_BYTE5 (uint16_t)0x0408
#define EEPROM_ALERT_MESSAGE2_BYTE6 (uint16_t)0x0409
#define EEPROM_ALERT_MESSAGE2_BYTE7 (uint16_t)0x040A
#define EEPROM_ALERT_MESSAGE2_BYTE8 (uint16_t)0x040B
#define EEPROM_ALERT_MESSAGE2_BYTE9 (uint16_t)0x040C
#define EEPROM_ALERT_MESSAGE2_BYTE10 (uint16_t)0x040D
#define EEPROM_ALERT_MESSAGE2_BYTE11 (uint16_t)0x040E
#define EEPROM_ALERT_MESSAGE2_BYTE12 (uint16_t)0x040F
#define EEPROM_ALERT_MESSAGE2_BYTE13 (uint16_t)0x0410
#define EEPROM_ALERT_MESSAGE2_BYTE14 (uint16_t)0x0411
#define EEPROM_ALERT_MESSAGE2_BYTE15 (uint16_t)0x0412
#define EEPROM_ALERT_MESSAGE2_BYTE16 (uint16_t)0x0413
#define EEPROM_ALERT_MESSAGE2_BYTE17 (uint16_t)0x0414
#define EEPROM_ALERT_MESSAGE2_BYTE18 (uint16_t)0x0415
#define EEPROM_ALERT_MESSAGE2_BYTE19 (uint16_t)0x0416
#define EEPROM_ALERT_MESSAGE2_BYTE20 (uint16_t)0x0417
#define EEPROM_ALERT_MESSAGE2_BYTE21 (uint16_t)0x0418
#define EEPROM_ALERT_MESSAGE2_BYTE22 (uint16_t)0x0419
#define EEPROM_ALERT_MESSAGE2_BYTE23 (uint16_t)0x041A
#define EEPROM_ALERT_MESSAGE2_BYTE24 (uint16_t)0x041B
#define EEPROM_ALERT_MESSAGE2_BYTE25 (uint16_t)0x041C
#define EEPROM_ALERT_MESSAGE2_BYTE26 (uint16_t)0x041D
#define EEPROM_ALERT_MESSAGE2_BYTE27 (uint16_t)0x041E
#define EEPROM_ALERT_MESSAGE2_BYTE28 (uint16_t)0x041F
#define EEPROM_ALERT_MESSAGE2_BYTE29 (uint16_t)0x0500
#define EEPROM_ALERT_MESSAGE2_BYTE30 (uint16_t)0x0501
#define EEPROM_ALERT_MESSAGE2_BYTE31 (uint16_t)0x0502
#define EEPROM_ALERT_MESSAGE2_BYTE32 (uint16_t)0x0503
#define EEPROM_ALERT_MESSAGE2_BYTE33 (uint16_t)0x0504
#define EEPROM_ALERT_MESSAGE2_BYTE34 (uint16_t)0x0505
#define EEPROM_ALERT_MESSAGE2_BYTE35 (uint16_t)0x0506
#define EEPROM_ALERT_MESSAGE2_BYTE36 (uint16_t)0x0507
#define EEPROM_ALERT_MESSAGE2_BYTE37 (uint16_t)0x0508
#define EEPROM_ALERT_MESSAGE2_BYTE38 (uint16_t)0x0509
#define EEPROM_ALERT_MESSAGE2_BYTE39 (uint16_t)0x050A
#define EEPROM_ALERT_MESSAGE2_BYTE40 (uint16_t)0x050B
#define EEPROM_ALERT_MESSAGE2_BYTE41 (uint16_t)0x050C
#define EEPROM_ALERT_MESSAGE2_BYTE42 (uint16_t)0x050D
#define EEPROM_ALERT_MESSAGE2_BYTE43 (uint16_t)0x050E
#define EEPROM_ALERT_MESSAGE2_BYTE44 (uint16_t)0x050F
#define EEPROM_ALERT_MESSAGE2_BYTE45 (uint16_t)0x0510
#define EEPROM_ALERT_MESSAGE2_BYTE46 (uint16_t)0x0511
#define EEPROM_ALERT_MESSAGE2_BYTE47 (uint16_t)0x0512
#define EEPROM_ALERT_MESSAGE2_BYTE48 (uint16_t)0x0513
#define EEPROM_ALERT_MESSAGE2_BYTE49 (uint16_t)0x0514
#define EEPROM_ALERT_MESSAGE2_BYTE50 (uint16_t)0x0515
#define EEPROM_ALERT_MESSAGE2_BYTE51 (uint16_t)0x0516
#define EEPROM_ALERT_MESSAGE2_BYTE52 (uint16_t)0x0517
#define EEPROM_ALERT_MESSAGE2_BYTE53 (uint16_t)0x0518
#define EEPROM_ALERT_MESSAGE2_BYTE54 (uint16_t)0x0519
#define EEPROM_ALERT_MESSAGE2_BYTE55 (uint16_t)0x051A
#define EEPROM_ALERT_MESSAGE2_BYTE56 (uint16_t)0x051B
#define EEPROM_ALERT_MESSAGE2_BYTE57 (uint16_t)0x051C
#define EEPROM_ALERT_MESSAGE2_BYTE58 (uint16_t)0x051D
#define EEPROM_ALERT_MESSAGE2_BYTE59 (uint16_t)0x051E
#define EEPROM_ALERT_MESSAGE2_BYTE60 (uint16_t)0x051F
#define EEPROM_ALERT_MESSAGE2_BYTE61 (uint16_t)0x0600
#define EEPROM_ALERT_MESSAGE2_BYTE62 (uint16_t)0x0601
#define EEPROM_ALERT_MESSAGE2_BYTE63 (uint16_t)0x0602
#define EEPROM_ALERT_MESSAGE2_BYTE64 (uint16_t)0x0603
#define EEPROM_ALERT_MESSAGE3_BYTE1 (uint16_t)0x0604
#define EEPROM_ALERT_MESSAGE3_BYTE2 (uint16_t)0x0605
#define EEPROM_ALERT_MESSAGE3_BYTE3 (uint16_t)0x0606
#define EEPROM_ALERT_MESSAGE3_BYTE4 (uint16_t)0x0607
#define EEPROM_ALERT_MESSAGE3_BYTE5 (uint16_t)0x0608
#define EEPROM_ALERT_MESSAGE3_BYTE6 (uint16_t)0x0609
#define EEPROM_ALERT_MESSAGE3_BYTE7 (uint16_t)0x060A
#define EEPROM_ALERT_MESSAGE3_BYTE8 (uint16_t)0x060B
#define EEPROM_ALERT_MESSAGE3_BYTE9 (uint16_t)0x060C
#define EEPROM_ALERT_MESSAGE3_BYTE10 (uint16_t)0x060D
#define EEPROM_ALERT_MESSAGE3_BYTE11 (uint16_t)0x060E
#define EEPROM_ALERT_MESSAGE3_BYTE12 (uint16_t)0x060F
#define EEPROM_ALERT_MESSAGE3_BYTE13 (uint16_t)0x0610
#define EEPROM_ALERT_MESSAGE3_BYTE14 (uint16_t)0x0611
#define EEPROM_ALERT_MESSAGE3_BYTE15 (uint16_t)0x0612
#define EEPROM_ALERT_MESSAGE3_BYTE16 (uint16_t)0x0613
#define EEPROM_ALERT_MESSAGE3_BYTE17 (uint16_t)0x0614
#define EEPROM_ALERT_MESSAGE3_BYTE18 (uint16_t)0x0615
#define EEPROM_ALERT_MESSAGE3_BYTE19 (uint16_t)0x0616
#define EEPROM_ALERT_MESSAGE3_BYTE20 (uint16_t)0x0617
#define EEPROM_ALERT_MESSAGE3_BYTE21 (uint16_t)0x0618
#define EEPROM_ALERT_MESSAGE3_BYTE22 (uint16_t)0x0619
#define EEPROM_ALERT_MESSAGE3_BYTE23 (uint16_t)0x061A
#define EEPROM_ALERT_MESSAGE3_BYTE24 (uint16_t)0x061B
#define EEPROM_ALERT_MESSAGE3_BYTE25 (uint16_t)0x061C
#define EEPROM_ALERT_MESSAGE3_BYTE26 (uint16_t)0x061D
#define EEPROM_ALERT_MESSAGE3_BYTE27 (uint16_t)0x061E
#define EEPROM_ALERT_MESSAGE3_BYTE28 (uint16_t)0x061F
#define EEPROM_ALERT_MESSAGE3_BYTE29 (uint16_t)0x0700
#define EEPROM_ALERT_MESSAGE3_BYTE30 (uint16_t)0x0701
#define EEPROM_ALERT_MESSAGE3_BYTE31 (uint16_t)0x0702
#define EEPROM_ALERT_MESSAGE3_BYTE32 (uint16_t)0x0703
#define EEPROM_ALERT_MESSAGE3_BYTE33 (uint16_t)0x0704
#define EEPROM_ALERT_MESSAGE3_BYTE34 (uint16_t)0x0705
#define EEPROM_ALERT_MESSAGE3_BYTE35 (uint16_t)0x0706
#define EEPROM_ALERT_MESSAGE3_BYTE36 (uint16_t)0x0707
#define EEPROM_ALERT_MESSAGE3_BYTE37 (uint16_t)0x0708
#define EEPROM_ALERT_MESSAGE3_BYTE38 (uint16_t)0x0709
#define EEPROM_ALERT_MESSAGE3_BYTE39 (uint16_t)0x070A
#define EEPROM_ALERT_MESSAGE3_BYTE40 (uint16_t)0x070B
#define EEPROM_ALERT_MESSAGE3_BYTE41 (uint16_t)0x070C
#define EEPROM_ALERT_MESSAGE3_BYTE42 (uint16_t)0x070D
#define EEPROM_ALERT_MESSAGE3_BYTE43 (uint16_t)0x070E
#define EEPROM_ALERT_MESSAGE3_BYTE44 (uint16_t)0x070F
#define EEPROM_ALERT_MESSAGE3_BYTE45 (uint16_t)0x0710
#define EEPROM_ALERT_MESSAGE3_BYTE46 (uint16_t)0x0711
#define EEPROM_ALERT_MESSAGE3_BYTE47 (uint16_t)0x0712
#define EEPROM_ALERT_MESSAGE3_BYTE48 (uint16_t)0x0713
#define EEPROM_ALERT_MESSAGE3_BYTE49 (uint16_t)0x0714
#define EEPROM_ALERT_MESSAGE3_BYTE50 (uint16_t)0x0715
#define EEPROM_ALERT_MESSAGE3_BYTE51 (uint16_t)0x0716
#define EEPROM_ALERT_MESSAGE3_BYTE52 (uint16_t)0x0717
#define EEPROM_ALERT_MESSAGE3_BYTE53 (uint16_t)0x0718
#define EEPROM_ALERT_MESSAGE3_BYTE54 (uint16_t)0x0719
#define EEPROM_ALERT_MESSAGE3_BYTE55 (uint16_t)0x071A
#define EEPROM_ALERT_MESSAGE3_BYTE56 (uint16_t)0x071B
#define EEPROM_ALERT_MESSAGE3_BYTE57 (uint16_t)0x071C
#define EEPROM_ALERT_MESSAGE3_BYTE58 (uint16_t)0x071D
#define EEPROM_ALERT_MESSAGE3_BYTE59 (uint16_t)0x071E
#define EEPROM_ALERT_MESSAGE3_BYTE60 (uint16_t)0x071F
#define EEPROM_ALERT_MESSAGE3_BYTE61 (uint16_t)0x0800
#define EEPROM_ALERT_MESSAGE3_BYTE62 (uint16_t)0x0801
#define EEPROM_ALERT_MESSAGE3_BYTE63 (uint16_t)0x0802
#define EEPROM_ALERT_MESSAGE3_BYTE64 (uint16_t)0x0803
#define EEPROM_ALERT_MESSAGE4_BYTE1 (uint16_t)0x0804
#define EEPROM_ALERT_MESSAGE4_BYTE2 (uint16_t)0x0805
#define EEPROM_ALERT_MESSAGE4_BYTE3 (uint16_t)0x0806
#define EEPROM_ALERT_MESSAGE4_BYTE4 (uint16_t)0x0807
#define EEPROM_ALERT_MESSAGE4_BYTE5 (uint16_t)0x0808
#define EEPROM_ALERT_MESSAGE4_BYTE6 (uint16_t)0x0809
#define EEPROM_ALERT_MESSAGE4_BYTE7 (uint16_t)0x080A
#define EEPROM_ALERT_MESSAGE4_BYTE8 (uint16_t)0x080B
#define EEPROM_ALERT_MESSAGE4_BYTE9 (uint16_t)0x080C
#define EEPROM_ALERT_MESSAGE4_BYTE10 (uint16_t)0x080D
#define EEPROM_ALERT_MESSAGE4_BYTE11 (uint16_t)0x080E
#define EEPROM_ALERT_MESSAGE4_BYTE12 (uint16_t)0x080F
#define EEPROM_ALERT_MESSAGE4_BYTE13 (uint16_t)0x0810
#define EEPROM_ALERT_MESSAGE4_BYTE14 (uint16_t)0x0811
#define EEPROM_ALERT_MESSAGE4_BYTE15 (uint16_t)0x0812
#define EEPROM_ALERT_MESSAGE4_BYTE16 (uint16_t)0x0813
#define EEPROM_ALERT_MESSAGE4_BYTE17 (uint16_t)0x0814
#define EEPROM_ALERT_MESSAGE4_BYTE18 (uint16_t)0x0815
#define EEPROM_ALERT_MESSAGE4_BYTE19 (uint16_t)0x0816
#define EEPROM_ALERT_MESSAGE4_BYTE20 (uint16_t)0x0817
#define EEPROM_ALERT_MESSAGE4_BYTE21 (uint16_t)0x0818
#define EEPROM_ALERT_MESSAGE4_BYTE22 (uint16_t)0x0819
#define EEPROM_ALERT_MESSAGE4_BYTE23 (uint16_t)0x081A
#define EEPROM_ALERT_MESSAGE4_BYTE24 (uint16_t)0x081B
#define EEPROM_ALERT_MESSAGE4_BYTE25 (uint16_t)0x081C
#define EEPROM_ALERT_MESSAGE4_BYTE26 (uint16_t)0x081D
#define EEPROM_ALERT_MESSAGE4_BYTE27 (uint16_t)0x081E
#define EEPROM_ALERT_MESSAGE4_BYTE28 (uint16_t)0x081F
#define EEPROM_ALERT_MESSAGE4_BYTE29 (uint16_t)0x0900
#define EEPROM_ALERT_MESSAGE4_BYTE30 (uint16_t)0x0901
#define EEPROM_ALERT_MESSAGE4_BYTE31 (uint16_t)0x0902
#define EEPROM_ALERT_MESSAGE4_BYTE32 (uint16_t)0x0903
#define EEPROM_ALERT_MESSAGE4_BYTE33 (uint16_t)0x0904
#define EEPROM_ALERT_MESSAGE4_BYTE34 (uint16_t)0x0905
#define EEPROM_ALERT_MESSAGE4_BYTE35 (uint16_t)0x0906
#define EEPROM_ALERT_MESSAGE4_BYTE36 (uint16_t)0x0907
#define EEPROM_ALERT_MESSAGE4_BYTE37 (uint16_t)0x0908
#define EEPROM_ALERT_MESSAGE4_BYTE38 (uint16_t)0x0909
#define EEPROM_ALERT_MESSAGE4_BYTE39 (uint16_t)0x090A
#define EEPROM_ALERT_MESSAGE4_BYTE40 (uint16_t)0x090B
#define EEPROM_ALERT_MESSAGE4_BYTE41 (uint16_t)0x090C
#define EEPROM_ALERT_MESSAGE4_BYTE42 (uint16_t)0x090D
#define EEPROM_ALERT_MESSAGE4_BYTE43 (uint16_t)0x090E
#define EEPROM_ALERT_MESSAGE4_BYTE44 (uint16_t)0x090F
#define EEPROM_ALERT_MESSAGE4_BYTE45 (uint16_t)0x0910
#define EEPROM_ALERT_MESSAGE4_BYTE46 (uint16_t)0x0911
#define EEPROM_ALERT_MESSAGE4_BYTE47 (uint16_t)0x0912
#define EEPROM_ALERT_MESSAGE4_BYTE48 (uint16_t)0x0913
#define EEPROM_ALERT_MESSAGE4_BYTE49 (uint16_t)0x0914
#define EEPROM_ALERT_MESSAGE4_BYTE50 (uint16_t)0x0915
#define EEPROM_ALERT_MESSAGE4_BYTE51 (uint16_t)0x0916
#define EEPROM_ALERT_MESSAGE4_BYTE52 (uint16_t)0x0917
#define EEPROM_ALERT_MESSAGE4_BYTE53 (uint16_t)0x0918
#define EEPROM_ALERT_MESSAGE4_BYTE54 (uint16_t)0x0919
#define EEPROM_ALERT_MESSAGE4_BYTE55 (uint16_t)0x091A
#define EEPROM_ALERT_MESSAGE4_BYTE56 (uint16_t)0x091B
#define EEPROM_ALERT_MESSAGE4_BYTE57 (uint16_t)0x091C
#define EEPROM_ALERT_MESSAGE4_BYTE58 (uint16_t)0x091D
#define EEPROM_ALERT_MESSAGE4_BYTE59 (uint16_t)0x091E
#define EEPROM_ALERT_MESSAGE4_BYTE60 (uint16_t)0x091F
#define EEPROM_ALERT_MESSAGE4_BYTE61 (uint16_t)0x0A00
#define EEPROM_ALERT_MESSAGE4_BYTE62 (uint16_t)0x0A01
#define EEPROM_ALERT_MESSAGE4_BYTE63 (uint16_t)0x0A02
#define EEPROM_ALERT_MESSAGE4_BYTE64 (uint16_t)0x0A03
#define EEPROM_ALERT_MESSAGE5_BYTE1 (uint16_t)0x0A04
#define EEPROM_ALERT_MESSAGE5_BYTE2 (uint16_t)0x0A05
#define EEPROM_ALERT_MESSAGE5_BYTE3 (uint16_t)0x0A06
#define EEPROM_ALERT_MESSAGE5_BYTE4 (uint16_t)0x0A07
#define EEPROM_ALERT_MESSAGE5_BYTE5 (uint16_t)0x0A08
#define EEPROM_ALERT_MESSAGE5_BYTE6 (uint16_t)0x0A09
#define EEPROM_ALERT_MESSAGE5_BYTE7 (uint16_t)0x0A0A
#define EEPROM_ALERT_MESSAGE5_BYTE8 (uint16_t)0x0A0B
#define EEPROM_ALERT_MESSAGE5_BYTE9 (uint16_t)0x0A0C
#define EEPROM_ALERT_MESSAGE5_BYTE10 (uint16_t)0x0A0D
#define EEPROM_ALERT_MESSAGE5_BYTE11 (uint16_t)0x0A0E
#define EEPROM_ALERT_MESSAGE5_BYTE12 (uint16_t)0x0A0F
#define EEPROM_ALERT_MESSAGE5_BYTE13 (uint16_t)0x0A10
#define EEPROM_ALERT_MESSAGE5_BYTE14 (uint16_t)0x0A11
#define EEPROM_ALERT_MESSAGE5_BYTE15 (uint16_t)0x0A12
#define EEPROM_ALERT_MESSAGE5_BYTE16 (uint16_t)0x0A13
#define EEPROM_ALERT_MESSAGE5_BYTE17 (uint16_t)0x0A14
#define EEPROM_ALERT_MESSAGE5_BYTE18 (uint16_t)0x0A15
#define EEPROM_ALERT_MESSAGE5_BYTE19 (uint16_t)0x0A16
#define EEPROM_ALERT_MESSAGE5_BYTE20 (uint16_t)0x0A17
#define EEPROM_ALERT_MESSAGE5_BYTE21 (uint16_t)0x0A18
#define EEPROM_ALERT_MESSAGE5_BYTE22 (uint16_t)0x0A19
#define EEPROM_ALERT_MESSAGE5_BYTE23 (uint16_t)0x0A1A
#define EEPROM_ALERT_MESSAGE5_BYTE24 (uint16_t)0x0A1B
#define EEPROM_ALERT_MESSAGE5_BYTE25 (uint16_t)0x0A1C
#define EEPROM_ALERT_MESSAGE5_BYTE26 (uint16_t)0x0A1D
#define EEPROM_ALERT_MESSAGE5_BYTE27 (uint16_t)0x0A1E
#define EEPROM_ALERT_MESSAGE5_BYTE28 (uint16_t)0x0A1F
#define EEPROM_ALERT_MESSAGE5_BYTE29 (uint16_t)0x0B00
#define EEPROM_ALERT_MESSAGE5_BYTE30 (uint16_t)0x0B01
#define EEPROM_ALERT_MESSAGE5_BYTE31 (uint16_t)0x0B02
#define EEPROM_ALERT_MESSAGE5_BYTE32 (uint16_t)0x0B03
#define EEPROM_ALERT_MESSAGE5_BYTE33 (uint16_t)0x0B04
#define EEPROM_ALERT_MESSAGE5_BYTE34 (uint16_t)0x0B05
#define EEPROM_ALERT_MESSAGE5_BYTE35 (uint16_t)0x0B06
#define EEPROM_ALERT_MESSAGE5_BYTE36 (uint16_t)0x0B07
#define EEPROM_ALERT_MESSAGE5_BYTE37 (uint16_t)0x0B08
#define EEPROM_ALERT_MESSAGE5_BYTE38 (uint16_t)0x0B09
#define EEPROM_ALERT_MESSAGE5_BYTE39 (uint16_t)0x0B0A
#define EEPROM_ALERT_MESSAGE5_BYTE40 (uint16_t)0x0B0B
#define EEPROM_ALERT_MESSAGE5_BYTE41 (uint16_t)0x0B0C
#define EEPROM_ALERT_MESSAGE5_BYTE42 (uint16_t)0x0B0D
#define EEPROM_ALERT_MESSAGE5_BYTE43 (uint16_t)0x0B0E
#define EEPROM_ALERT_MESSAGE5_BYTE44 (uint16_t)0x0B0F
#define EEPROM_ALERT_MESSAGE5_BYTE45 (uint16_t)0x0B10
#define EEPROM_ALERT_MESSAGE5_BYTE46 (uint16_t)0x0B11
#define EEPROM_ALERT_MESSAGE5_BYTE47 (uint16_t)0x0B12
#define EEPROM_ALERT_MESSAGE5_BYTE48 (uint16_t)0x0B13
#define EEPROM_ALERT_MESSAGE5_BYTE49 (uint16_t)0x0B14
#define EEPROM_ALERT_MESSAGE5_BYTE50 (uint16_t)0x0B15
#define EEPROM_ALERT_MESSAGE5_BYTE51 (uint16_t)0x0B16
#define EEPROM_ALERT_MESSAGE5_BYTE52 (uint16_t)0x0B17
#define EEPROM_ALERT_MESSAGE5_BYTE53 (uint16_t)0x0B18
#define EEPROM_ALERT_MESSAGE5_BYTE54 (uint16_t)0x0B19
#define EEPROM_ALERT_MESSAGE5_BYTE55 (uint16_t)0x0B1A
#define EEPROM_ALERT_MESSAGE5_BYTE56 (uint16_t)0x0B1B
#define EEPROM_ALERT_MESSAGE5_BYTE57 (uint16_t)0x0B1C
#define EEPROM_ALERT_MESSAGE5_BYTE58 (uint16_t)0x0B1D
#define EEPROM_ALERT_MESSAGE5_BYTE59 (uint16_t)0x0B1E
#define EEPROM_ALERT_MESSAGE5_BYTE60 (uint16_t)0x0B1F
#define EEPROM_ALERT_MESSAGE5_BYTE61 (uint16_t)0x0C00
#define EEPROM_ALERT_MESSAGE5_BYTE62 (uint16_t)0x0C01
#define EEPROM_ALERT_MESSAGE5_BYTE63 (uint16_t)0x0C02
#define EEPROM_ALERT_MESSAGE5_BYTE64 (uint16_t)0x0C03
static const uint16_t map_alert_message_byte1[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE1,
    EEPROM_ALERT_MESSAGE2_BYTE1,
    EEPROM_ALERT_MESSAGE3_BYTE1,
    EEPROM_ALERT_MESSAGE4_BYTE1,
    EEPROM_ALERT_MESSAGE5_BYTE1
    };

static const uint16_t map_alert_message_byte2[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE2,
    EEPROM_ALERT_MESSAGE2_BYTE2,
    EEPROM_ALERT_MESSAGE3_BYTE2,
    EEPROM_ALERT_MESSAGE4_BYTE2,
    EEPROM_ALERT_MESSAGE5_BYTE2
    };

static const uint16_t map_alert_message_byte3[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE3,
    EEPROM_ALERT_MESSAGE2_BYTE3,
    EEPROM_ALERT_MESSAGE3_BYTE3,
    EEPROM_ALERT_MESSAGE4_BYTE3,
    EEPROM_ALERT_MESSAGE5_BYTE3
    };

static const uint16_t map_alert_message_byte4[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE4,
    EEPROM_ALERT_MESSAGE2_BYTE4,
    EEPROM_ALERT_MESSAGE3_BYTE4,
    EEPROM_ALERT_MESSAGE4_BYTE4,
    EEPROM_ALERT_MESSAGE5_BYTE4
    };

static const uint16_t map_alert_message_byte5[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE5,
    EEPROM_ALERT_MESSAGE2_BYTE5,
    EEPROM_ALERT_MESSAGE3_BYTE5,
    EEPROM_ALERT_MESSAGE4_BYTE5,
    EEPROM_ALERT_MESSAGE5_BYTE5
    };

static const uint16_t map_alert_message_byte6[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE6,
    EEPROM_ALERT_MESSAGE2_BYTE6,
    EEPROM_ALERT_MESSAGE3_BYTE6,
    EEPROM_ALERT_MESSAGE4_BYTE6,
    EEPROM_ALERT_MESSAGE5_BYTE6
    };

static const uint16_t map_alert_message_byte7[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE7,
    EEPROM_ALERT_MESSAGE2_BYTE7,
    EEPROM_ALERT_MESSAGE3_BYTE7,
    EEPROM_ALERT_MESSAGE4_BYTE7,
    EEPROM_ALERT_MESSAGE5_BYTE7
    };

static const uint16_t map_alert_message_byte8[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE8,
    EEPROM_ALERT_MESSAGE2_BYTE8,
    EEPROM_ALERT_MESSAGE3_BYTE8,
    EEPROM_ALERT_MESSAGE4_BYTE8,
    EEPROM_ALERT_MESSAGE5_BYTE8
    };

static const uint16_t map_alert_message_byte9[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE9,
    EEPROM_ALERT_MESSAGE2_BYTE9,
    EEPROM_ALERT_MESSAGE3_BYTE9,
    EEPROM_ALERT_MESSAGE4_BYTE9,
    EEPROM_ALERT_MESSAGE5_BYTE9
    };

static const uint16_t map_alert_message_byte10[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE10,
    EEPROM_ALERT_MESSAGE2_BYTE10,
    EEPROM_ALERT_MESSAGE3_BYTE10,
    EEPROM_ALERT_MESSAGE4_BYTE10,
    EEPROM_ALERT_MESSAGE5_BYTE10
    };

static const uint16_t map_alert_message_byte11[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE11,
    EEPROM_ALERT_MESSAGE2_BYTE11,
    EEPROM_ALERT_MESSAGE3_BYTE11,
    EEPROM_ALERT_MESSAGE4_BYTE11,
    EEPROM_ALERT_MESSAGE5_BYTE11
    };

static const uint16_t map_alert_message_byte12[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE12,
    EEPROM_ALERT_MESSAGE2_BYTE12,
    EEPROM_ALERT_MESSAGE3_BYTE12,
    EEPROM_ALERT_MESSAGE4_BYTE12,
    EEPROM_ALERT_MESSAGE5_BYTE12
    };

static const uint16_t map_alert_message_byte13[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE13,
    EEPROM_ALERT_MESSAGE2_BYTE13,
    EEPROM_ALERT_MESSAGE3_BYTE13,
    EEPROM_ALERT_MESSAGE4_BYTE13,
    EEPROM_ALERT_MESSAGE5_BYTE13
    };

static const uint16_t map_alert_message_byte14[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE14,
    EEPROM_ALERT_MESSAGE2_BYTE14,
    EEPROM_ALERT_MESSAGE3_BYTE14,
    EEPROM_ALERT_MESSAGE4_BYTE14,
    EEPROM_ALERT_MESSAGE5_BYTE14
    };

static const uint16_t map_alert_message_byte15[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE15,
    EEPROM_ALERT_MESSAGE2_BYTE15,
    EEPROM_ALERT_MESSAGE3_BYTE15,
    EEPROM_ALERT_MESSAGE4_BYTE15,
    EEPROM_ALERT_MESSAGE5_BYTE15
    };

static const uint16_t map_alert_message_byte16[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE16,
    EEPROM_ALERT_MESSAGE2_BYTE16,
    EEPROM_ALERT_MESSAGE3_BYTE16,
    EEPROM_ALERT_MESSAGE4_BYTE16,
    EEPROM_ALERT_MESSAGE5_BYTE16
    };

static const uint16_t map_alert_message_byte17[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE17,
    EEPROM_ALERT_MESSAGE2_BYTE17,
    EEPROM_ALERT_MESSAGE3_BYTE17,
    EEPROM_ALERT_MESSAGE4_BYTE17,
    EEPROM_ALERT_MESSAGE5_BYTE17
    };

static const uint16_t map_alert_message_byte18[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE18,
    EEPROM_ALERT_MESSAGE2_BYTE18,
    EEPROM_ALERT_MESSAGE3_BYTE18,
    EEPROM_ALERT_MESSAGE4_BYTE18,
    EEPROM_ALERT_MESSAGE5_BYTE18
    };

static const uint16_t map_alert_message_byte19[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE19,
    EEPROM_ALERT_MESSAGE2_BYTE19,
    EEPROM_ALERT_MESSAGE3_BYTE19,
    EEPROM_ALERT_MESSAGE4_BYTE19,
    EEPROM_ALERT_MESSAGE5_BYTE19
    };

static const uint16_t map_alert_message_byte20[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE20,
    EEPROM_ALERT_MESSAGE2_BYTE20,
    EEPROM_ALERT_MESSAGE3_BYTE20,
    EEPROM_ALERT_MESSAGE4_BYTE20,
    EEPROM_ALERT_MESSAGE5_BYTE20
    };

static const uint16_t map_alert_message_byte21[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE21,
    EEPROM_ALERT_MESSAGE2_BYTE21,
    EEPROM_ALERT_MESSAGE3_BYTE21,
    EEPROM_ALERT_MESSAGE4_BYTE21,
    EEPROM_ALERT_MESSAGE5_BYTE21
    };

static const uint16_t map_alert_message_byte22[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE22,
    EEPROM_ALERT_MESSAGE2_BYTE22,
    EEPROM_ALERT_MESSAGE3_BYTE22,
    EEPROM_ALERT_MESSAGE4_BYTE22,
    EEPROM_ALERT_MESSAGE5_BYTE22
    };

static const uint16_t map_alert_message_byte23[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE23,
    EEPROM_ALERT_MESSAGE2_BYTE23,
    EEPROM_ALERT_MESSAGE3_BYTE23,
    EEPROM_ALERT_MESSAGE4_BYTE23,
    EEPROM_ALERT_MESSAGE5_BYTE23
    };

static const uint16_t map_alert_message_byte24[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE24,
    EEPROM_ALERT_MESSAGE2_BYTE24,
    EEPROM_ALERT_MESSAGE3_BYTE24,
    EEPROM_ALERT_MESSAGE4_BYTE24,
    EEPROM_ALERT_MESSAGE5_BYTE24
    };

static const uint16_t map_alert_message_byte25[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE25,
    EEPROM_ALERT_MESSAGE2_BYTE25,
    EEPROM_ALERT_MESSAGE3_BYTE25,
    EEPROM_ALERT_MESSAGE4_BYTE25,
    EEPROM_ALERT_MESSAGE5_BYTE25
    };

static const uint16_t map_alert_message_byte26[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE26,
    EEPROM_ALERT_MESSAGE2_BYTE26,
    EEPROM_ALERT_MESSAGE3_BYTE26,
    EEPROM_ALERT_MESSAGE4_BYTE26,
    EEPROM_ALERT_MESSAGE5_BYTE26
    };

static const uint16_t map_alert_message_byte27[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE27,
    EEPROM_ALERT_MESSAGE2_BYTE27,
    EEPROM_ALERT_MESSAGE3_BYTE27,
    EEPROM_ALERT_MESSAGE4_BYTE27,
    EEPROM_ALERT_MESSAGE5_BYTE27
    };

static const uint16_t map_alert_message_byte28[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE28,
    EEPROM_ALERT_MESSAGE2_BYTE28,
    EEPROM_ALERT_MESSAGE3_BYTE28,
    EEPROM_ALERT_MESSAGE4_BYTE28,
    EEPROM_ALERT_MESSAGE5_BYTE28
    };

static const uint16_t map_alert_message_byte29[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE29,
    EEPROM_ALERT_MESSAGE2_BYTE29,
    EEPROM_ALERT_MESSAGE3_BYTE29,
    EEPROM_ALERT_MESSAGE4_BYTE29,
    EEPROM_ALERT_MESSAGE5_BYTE29
    };

static const uint16_t map_alert_message_byte30[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE30,
    EEPROM_ALERT_MESSAGE2_BYTE30,
    EEPROM_ALERT_MESSAGE3_BYTE30,
    EEPROM_ALERT_MESSAGE4_BYTE30,
    EEPROM_ALERT_MESSAGE5_BYTE30
    };

static const uint16_t map_alert_message_byte31[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE31,
    EEPROM_ALERT_MESSAGE2_BYTE31,
    EEPROM_ALERT_MESSAGE3_BYTE31,
    EEPROM_ALERT_MESSAGE4_BYTE31,
    EEPROM_ALERT_MESSAGE5_BYTE31
    };

static const uint16_t map_alert_message_byte32[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE32,
    EEPROM_ALERT_MESSAGE2_BYTE32,
    EEPROM_ALERT_MESSAGE3_BYTE32,
    EEPROM_ALERT_MESSAGE4_BYTE32,
    EEPROM_ALERT_MESSAGE5_BYTE32
    };

static const uint16_t map_alert_message_byte33[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE33,
    EEPROM_ALERT_MESSAGE2_BYTE33,
    EEPROM_ALERT_MESSAGE3_BYTE33,
    EEPROM_ALERT_MESSAGE4_BYTE33,
    EEPROM_ALERT_MESSAGE5_BYTE33
    };

static const uint16_t map_alert_message_byte34[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE34,
    EEPROM_ALERT_MESSAGE2_BYTE34,
    EEPROM_ALERT_MESSAGE3_BYTE34,
    EEPROM_ALERT_MESSAGE4_BYTE34,
    EEPROM_ALERT_MESSAGE5_BYTE34
    };

static const uint16_t map_alert_message_byte35[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE35,
    EEPROM_ALERT_MESSAGE2_BYTE35,
    EEPROM_ALERT_MESSAGE3_BYTE35,
    EEPROM_ALERT_MESSAGE4_BYTE35,
    EEPROM_ALERT_MESSAGE5_BYTE35
    };

static const uint16_t map_alert_message_byte36[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE36,
    EEPROM_ALERT_MESSAGE2_BYTE36,
    EEPROM_ALERT_MESSAGE3_BYTE36,
    EEPROM_ALERT_MESSAGE4_BYTE36,
    EEPROM_ALERT_MESSAGE5_BYTE36
    };

static const uint16_t map_alert_message_byte37[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE37,
    EEPROM_ALERT_MESSAGE2_BYTE37,
    EEPROM_ALERT_MESSAGE3_BYTE37,
    EEPROM_ALERT_MESSAGE4_BYTE37,
    EEPROM_ALERT_MESSAGE5_BYTE37
    };

static const uint16_t map_alert_message_byte38[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE38,
    EEPROM_ALERT_MESSAGE2_BYTE38,
    EEPROM_ALERT_MESSAGE3_BYTE38,
    EEPROM_ALERT_MESSAGE4_BYTE38,
    EEPROM_ALERT_MESSAGE5_BYTE38
    };

static const uint16_t map_alert_message_byte39[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE39,
    EEPROM_ALERT_MESSAGE2_BYTE39,
    EEPROM_ALERT_MESSAGE3_BYTE39,
    EEPROM_ALERT_MESSAGE4_BYTE39,
    EEPROM_ALERT_MESSAGE5_BYTE39
    };

static const uint16_t map_alert_message_byte40[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE40,
    EEPROM_ALERT_MESSAGE2_BYTE40,
    EEPROM_ALERT_MESSAGE3_BYTE40,
    EEPROM_ALERT_MESSAGE4_BYTE40,
    EEPROM_ALERT_MESSAGE5_BYTE40
    };

static const uint16_t map_alert_message_byte41[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE41,
    EEPROM_ALERT_MESSAGE2_BYTE41,
    EEPROM_ALERT_MESSAGE3_BYTE41,
    EEPROM_ALERT_MESSAGE4_BYTE41,
    EEPROM_ALERT_MESSAGE5_BYTE41
    };

static const uint16_t map_alert_message_byte42[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE42,
    EEPROM_ALERT_MESSAGE2_BYTE42,
    EEPROM_ALERT_MESSAGE3_BYTE42,
    EEPROM_ALERT_MESSAGE4_BYTE42,
    EEPROM_ALERT_MESSAGE5_BYTE42
    };

static const uint16_t map_alert_message_byte43[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE43,
    EEPROM_ALERT_MESSAGE2_BYTE43,
    EEPROM_ALERT_MESSAGE3_BYTE43,
    EEPROM_ALERT_MESSAGE4_BYTE43,
    EEPROM_ALERT_MESSAGE5_BYTE43
    };

static const uint16_t map_alert_message_byte44[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE44,
    EEPROM_ALERT_MESSAGE2_BYTE44,
    EEPROM_ALERT_MESSAGE3_BYTE44,
    EEPROM_ALERT_MESSAGE4_BYTE44,
    EEPROM_ALERT_MESSAGE5_BYTE44
    };

static const uint16_t map_alert_message_byte45[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE45,
    EEPROM_ALERT_MESSAGE2_BYTE45,
    EEPROM_ALERT_MESSAGE3_BYTE45,
    EEPROM_ALERT_MESSAGE4_BYTE45,
    EEPROM_ALERT_MESSAGE5_BYTE45
    };

static const uint16_t map_alert_message_byte46[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE46,
    EEPROM_ALERT_MESSAGE2_BYTE46,
    EEPROM_ALERT_MESSAGE3_BYTE46,
    EEPROM_ALERT_MESSAGE4_BYTE46,
    EEPROM_ALERT_MESSAGE5_BYTE46
    };

static const uint16_t map_alert_message_byte47[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE47,
    EEPROM_ALERT_MESSAGE2_BYTE47,
    EEPROM_ALERT_MESSAGE3_BYTE47,
    EEPROM_ALERT_MESSAGE4_BYTE47,
    EEPROM_ALERT_MESSAGE5_BYTE47
    };

static const uint16_t map_alert_message_byte48[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE48,
    EEPROM_ALERT_MESSAGE2_BYTE48,
    EEPROM_ALERT_MESSAGE3_BYTE48,
    EEPROM_ALERT_MESSAGE4_BYTE48,
    EEPROM_ALERT_MESSAGE5_BYTE48
    };

static const uint16_t map_alert_message_byte49[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE49,
    EEPROM_ALERT_MESSAGE2_BYTE49,
    EEPROM_ALERT_MESSAGE3_BYTE49,
    EEPROM_ALERT_MESSAGE4_BYTE49,
    EEPROM_ALERT_MESSAGE5_BYTE49
    };

static const uint16_t map_alert_message_byte50[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE50,
    EEPROM_ALERT_MESSAGE2_BYTE50,
    EEPROM_ALERT_MESSAGE3_BYTE50,
    EEPROM_ALERT_MESSAGE4_BYTE50,
    EEPROM_ALERT_MESSAGE5_BYTE50
    };

static const uint16_t map_alert_message_byte51[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE51,
    EEPROM_ALERT_MESSAGE2_BYTE51,
    EEPROM_ALERT_MESSAGE3_BYTE51,
    EEPROM_ALERT_MESSAGE4_BYTE51,
    EEPROM_ALERT_MESSAGE5_BYTE51
    };

static const uint16_t map_alert_message_byte52[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE52,
    EEPROM_ALERT_MESSAGE2_BYTE52,
    EEPROM_ALERT_MESSAGE3_BYTE52,
    EEPROM_ALERT_MESSAGE4_BYTE52,
    EEPROM_ALERT_MESSAGE5_BYTE52
    };

static const uint16_t map_alert_message_byte53[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE53,
    EEPROM_ALERT_MESSAGE2_BYTE53,
    EEPROM_ALERT_MESSAGE3_BYTE53,
    EEPROM_ALERT_MESSAGE4_BYTE53,
    EEPROM_ALERT_MESSAGE5_BYTE53
    };

static const uint16_t map_alert_message_byte54[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE54,
    EEPROM_ALERT_MESSAGE2_BYTE54,
    EEPROM_ALERT_MESSAGE3_BYTE54,
    EEPROM_ALERT_MESSAGE4_BYTE54,
    EEPROM_ALERT_MESSAGE5_BYTE54
    };

static const uint16_t map_alert_message_byte55[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE55,
    EEPROM_ALERT_MESSAGE2_BYTE55,
    EEPROM_ALERT_MESSAGE3_BYTE55,
    EEPROM_ALERT_MESSAGE4_BYTE55,
    EEPROM_ALERT_MESSAGE5_BYTE55
    };

static const uint16_t map_alert_message_byte56[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE56,
    EEPROM_ALERT_MESSAGE2_BYTE56,
    EEPROM_ALERT_MESSAGE3_BYTE56,
    EEPROM_ALERT_MESSAGE4_BYTE56,
    EEPROM_ALERT_MESSAGE5_BYTE56
    };

static const uint16_t map_alert_message_byte57[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE57,
    EEPROM_ALERT_MESSAGE2_BYTE57,
    EEPROM_ALERT_MESSAGE3_BYTE57,
    EEPROM_ALERT_MESSAGE4_BYTE57,
    EEPROM_ALERT_MESSAGE5_BYTE57
    };

static const uint16_t map_alert_message_byte58[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE58,
    EEPROM_ALERT_MESSAGE2_BYTE58,
    EEPROM_ALERT_MESSAGE3_BYTE58,
    EEPROM_ALERT_MESSAGE4_BYTE58,
    EEPROM_ALERT_MESSAGE5_BYTE58
    };

static const uint16_t map_alert_message_byte59[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE59,
    EEPROM_ALERT_MESSAGE2_BYTE59,
    EEPROM_ALERT_MESSAGE3_BYTE59,
    EEPROM_ALERT_MESSAGE4_BYTE59,
    EEPROM_ALERT_MESSAGE5_BYTE59
    };

static const uint16_t map_alert_message_byte60[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE60,
    EEPROM_ALERT_MESSAGE2_BYTE60,
    EEPROM_ALERT_MESSAGE3_BYTE60,
    EEPROM_ALERT_MESSAGE4_BYTE60,
    EEPROM_ALERT_MESSAGE5_BYTE60
    };

static const uint16_t map_alert_message_byte61[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE61,
    EEPROM_ALERT_MESSAGE2_BYTE61,
    EEPROM_ALERT_MESSAGE3_BYTE61,
    EEPROM_ALERT_MESSAGE4_BYTE61,
    EEPROM_ALERT_MESSAGE5_BYTE61
    };

static const uint16_t map_alert_message_byte62[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE62,
    EEPROM_ALERT_MESSAGE2_BYTE62,
    EEPROM_ALERT_MESSAGE3_BYTE62,
    EEPROM_ALERT_MESSAGE4_BYTE62,
    EEPROM_ALERT_MESSAGE5_BYTE62
    };

static const uint16_t map_alert_message_byte63[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE63,
    EEPROM_ALERT_MESSAGE2_BYTE63,
    EEPROM_ALERT_MESSAGE3_BYTE63,
    EEPROM_ALERT_MESSAGE4_BYTE63,
    EEPROM_ALERT_MESSAGE5_BYTE63
    };

static const uint16_t map_alert_message_byte64[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE64,
    EEPROM_ALERT_MESSAGE2_BYTE64,
    EEPROM_ALERT_MESSAGE3_BYTE64,
    EEPROM_ALERT_MESSAGE4_BYTE64,
    EEPROM_ALERT_MESSAGE5_BYTE64
    };

// EEPROM Memory Map - alert compare
#define EEPROM_ALERT_COMPARE1_BYTE1 (uint16_t)0x0C04
#define EEPROM_ALERT_COMPARE2_BYTE1 (uint16_t)0x0C05
#define EEPROM_ALERT_COMPARE3_BYTE1 (uint16_t)0x0C06
#define EEPROM_ALERT_COMPARE4_BYTE1 (uint16_t)0x0C07
#define EEPROM_ALERT_COMPARE5_BYTE1 (uint16_t)0x0C08
static const uint16_t map_alert_compare_byte1[MAX_ALERTS] = {
    EEPROM_ALERT_COMPARE1_BYTE1,
    EEPROM_ALERT_COMPARE2_BYTE1,
    EEPROM_ALERT_COMPARE3_BYTE1,
    EEPROM_ALERT_COMPARE4_BYTE1,
    EEPROM_ALERT_COMPARE5_BYTE1
    };

// EEPROM Memory Map - alert threshold
#define EEPROM_ALERT_THRESHOLD1_BYTE1 (uint16_t)0x0C09
#define EEPROM_ALERT_THRESHOLD1_BYTE2 (uint16_t)0x0C0A
#define EEPROM_ALERT_THRESHOLD1_BYTE3 (uint16_t)0x0C0B
#define EEPROM_ALERT_THRESHOLD1_BYTE4 (uint16_t)0x0C0C
#define EEPROM_ALERT_THRESHOLD2_BYTE1 (uint16_t)0x0C0D
#define EEPROM_ALERT_THRESHOLD2_BYTE2 (uint16_t)0x0C0E
#define EEPROM_ALERT_THRESHOLD2_BYTE3 (uint16_t)0x0C0F
#define EEPROM_ALERT_THRESHOLD2_BYTE4 (uint16_t)0x0C10
static const uint16_t map_alert_threshold_byte1[NUM_DYNAMIC] = {
    EEPROM_ALERT_THRESHOLD1_BYTE1,
    EEPROM_ALERT_THRESHOLD2_BYTE1
    };

static const uint16_t map_alert_threshold_byte2[NUM_DYNAMIC] = {
    EEPROM_ALERT_THRESHOLD1_BYTE2,
    EEPROM_ALERT_THRESHOLD2_BYTE2
    };

static const uint16_t map_alert_threshold_byte3[NUM_DYNAMIC] = {
    EEPROM_ALERT_THRESHOLD1_BYTE3,
    EEPROM_ALERT_THRESHOLD2_BYTE3
    };

static const uint16_t map_alert_threshold_byte4[NUM_DYNAMIC] = {
    EEPROM_ALERT_THRESHOLD1_BYTE4,
    EEPROM_ALERT_THRESHOLD2_BYTE4
    };

// EEPROM Memory Map - dynamic enable
#define EEPROM_DYNAMIC_ENABLE1_BYTE1 (uint16_t)0x0C11
#define EEPROM_DYNAMIC_ENABLE2_BYTE1 (uint16_t)0x0C12
static const uint16_t map_dynamic_enable_byte1[NUM_DYNAMIC] = {
    EEPROM_DYNAMIC_ENABLE1_BYTE1,
    EEPROM_DYNAMIC_ENABLE2_BYTE1
    };

// EEPROM Memory Map - dynamic priority
#define EEPROM_DYNAMIC_PRIORITY1_BYTE1 (uint16_t)0x0C13
#define EEPROM_DYNAMIC_PRIORITY2_BYTE1 (uint16_t)0x0C14
static const uint16_t map_dynamic_priority_byte1[NUM_DYNAMIC] = {
    EEPROM_DYNAMIC_PRIORITY1_BYTE1,
    EEPROM_DYNAMIC_PRIORITY2_BYTE1
    };

// EEPROM Memory Map - dynamic compare
#define EEPROM_DYNAMIC_COMPARE1_BYTE1 (uint16_t)0x0C15
#define EEPROM_DYNAMIC_COMPARE2_BYTE1 (uint16_t)0x0C16
#define EEPROM_DYNAMIC_COMPARE3_BYTE1 (uint16_t)0x0C17
#define EEPROM_DYNAMIC_COMPARE4_BYTE1 (uint16_t)0x0C18
#define EEPROM_DYNAMIC_COMPARE5_BYTE1 (uint16_t)0x0C19
static const uint16_t map_dynamic_compare_byte1[MAX_ALERTS] = {
    EEPROM_DYNAMIC_COMPARE1_BYTE1,
    EEPROM_DYNAMIC_COMPARE2_BYTE1,
    EEPROM_DYNAMIC_COMPARE3_BYTE1,
    EEPROM_DYNAMIC_COMPARE4_BYTE1,
    EEPROM_DYNAMIC_COMPARE5_BYTE1
    };

// EEPROM Memory Map - dynamic Threshold
#define EEPROM_DYNAMIC_THRESHOLD1_BYTE1 (uint16_t)0x0C1A
#define EEPROM_DYNAMIC_THRESHOLD1_BYTE2 (uint16_t)0x0C1B
#define EEPROM_DYNAMIC_THRESHOLD1_BYTE3 (uint16_t)0x0C1C
#define EEPROM_DYNAMIC_THRESHOLD1_BYTE4 (uint16_t)0x0C1D
#define EEPROM_DYNAMIC_THRESHOLD2_BYTE1 (uint16_t)0x0C1E
#define EEPROM_DYNAMIC_THRESHOLD2_BYTE2 (uint16_t)0x0C1F
#define EEPROM_DYNAMIC_THRESHOLD2_BYTE3 (uint16_t)0x0D00
#define EEPROM_DYNAMIC_THRESHOLD2_BYTE4 (uint16_t)0x0D01
static const uint16_t map_dynamic_threshold_byte1[NUM_DYNAMIC] = {
    EEPROM_DYNAMIC_THRESHOLD1_BYTE1,
    EEPROM_DYNAMIC_THRESHOLD2_BYTE1
    };

static const uint16_t map_dynamic_threshold_byte2[NUM_DYNAMIC] = {
    EEPROM_DYNAMIC_THRESHOLD1_BYTE2,
    EEPROM_DYNAMIC_THRESHOLD2_BYTE2
    };

static const uint16_t map_dynamic_threshold_byte3[NUM_DYNAMIC] = {
    EEPROM_DYNAMIC_THRESHOLD1_BYTE3,
    EEPROM_DYNAMIC_THRESHOLD2_BYTE3
    };

static const uint16_t map_dynamic_threshold_byte4[NUM_DYNAMIC] = {
    EEPROM_DYNAMIC_THRESHOLD1_BYTE4,
    EEPROM_DYNAMIC_THRESHOLD2_BYTE4
    };

// EEPROM Memory Map - dynamic Index
#define EEPROM_DYNAMIC_INDEX1_BYTE1 (uint16_t)0x0D02
#define EEPROM_DYNAMIC_INDEX2_BYTE1 (uint16_t)0x0D03
static const uint16_t map_dynamic_index_byte1[NUM_DYNAMIC] = {
    EEPROM_DYNAMIC_INDEX1_BYTE1,
    EEPROM_DYNAMIC_INDEX2_BYTE1
    };


static VIEW_STATE settings_view_enable[MAX_VIEWS] = {DEFAULT_VIEW_ENABLE};
static uint8_t settings_view_num_gauges[GAUGES_PER_VIEW] = {DEFAULT_VIEW_NUM_GAUGES};
static VIEW_BACKGROUND settings_view_background[MAX_VIEWS] = {DEFAULT_VIEW_BACKGROUND};
static GAUGE_THEME settings_view_gauge_theme[MAX_VIEWS][GAUGES_PER_VIEW] = {DEFAULT_VIEW_GAUGE_THEME};
static uint32_t settings_view_gauge_pid[MAX_VIEWS][GAUGES_PER_VIEW] = {DEFAULT_VIEW_GAUGE_PID};
static PID_UNITS settings_view_gauge_units[MAX_VIEWS][GAUGES_PER_VIEW] = {DEFAULT_VIEW_GAUGE_UNITS};
static ALERT_STATE settings_alert_enable[MAX_ALERTS] = {DEFAULT_ALERT_ENABLE};
static char settings_alert_message[MAX_ALERTS][ALERT_MESSAGE_LEN] = {DEFAULT_ALERT_MESSAGE};
static ALERT_COMPARISON settings_alert_compare[MAX_ALERTS] = {DEFAULT_ALERT_COMPARE};
static float settings_alert_threshold[NUM_DYNAMIC] = {DEFAULT_ALERT_THRESHOLD};
static DYNAMIC_STATE settings_dynamic_enable[NUM_DYNAMIC] = {DEFAULT_DYNAMIC_ENABLE};
static DYNAMIC_PRIORITY settings_dynamic_priority[NUM_DYNAMIC] = {DEFAULT_DYNAMIC_PRIORITY};
static DYNAMIC_COMPARISON settings_dynamic_compare[MAX_ALERTS] = {DEFAULT_DYNAMIC_COMPARE};
static float settings_dynamic_threshold[NUM_DYNAMIC] = {DEFAULT_DYNAMIC_THRESHOLD};
static uint8_t settings_dynamic_index[NUM_DYNAMIC] = {DEFAULT_DYNAMIC_INDEX};




/********************************************************************************
*                                  View enable                                  
*
* @param idx_view    index of the view
* @param enable    Enable or disable view by index
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static VIEW_STATE load_view_enable(uint8_t idx)
{
    VIEW_STATE load_view_enable_val = DEFAULT_VIEW_ENABLE;

    if (true)
    {
        load_view_enable_val = (uint8_t)read(map_view_enable_byte1[idx]);
    }
    return load_view_enable_val;
}

static void save_view_enable(uint8_t idx, VIEW_STATE view_enable)
{
    if (true)
    {
        write(map_view_enable_byte1[idx], (uint32_t)view_enable & 0xFF);
    }
}

bool verify_view_enable(VIEW_STATE view_enable)
{
    if (view_enable >= VIEW_STATE_RESERVED)
        return 0;
    else
        return 1;
}

VIEW_STATE get_view_enable(uint8_t idx)
{
    // Verify the View enable value is valid
    if (!verify_view_enable(settings_view_enable[idx]))
        return DEFAULT_VIEW_ENABLE;

    return settings_view_enable[idx];
}

// Set the View enable
bool set_view_enable(uint8_t idx, VIEW_STATE view_enable, bool save)
{
    // Verify the View enable value is valid
    if (!verify_view_enable(view_enable))
        return false;

    // Check to see if the View enable EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        if (load_view_enable(idx) != view_enable)
        {
            save_view_enable(idx, view_enable);
        }
    }

    settings_view_enable[idx] = view_enable;

    return 1;
}


/********************************************************************************
*                                Number of gauges                               
*
* @param idx_view    index of the view
* @param num_gauges    Define the number of gauges for view by index
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static uint8_t load_view_num_gauges(uint8_t idx)
{
    uint8_t load_view_num_gauges_val = DEFAULT_VIEW_NUM_GAUGES;

    if (true)
    {
        load_view_num_gauges_val = (uint8_t)read(map_view_num_gauges_byte1[idx]);
    }
    return load_view_num_gauges_val;
}

static void save_view_num_gauges(uint8_t idx, uint8_t view_num_gauges)
{
    if (true)
    {
        write(map_view_num_gauges_byte1[idx], (uint32_t)view_num_gauges & 0xFF);
    }
}

bool verify_view_num_gauges(uint8_t view_num_gauges)
{
    if (view_num_gauges > GAUGES_PER_VIEW)
        return 0;

    else
        return 1;
}

uint8_t get_view_num_gauges(uint8_t idx)
{
    // Verify the Number of gauges value is valid
    if (!verify_view_num_gauges(settings_view_num_gauges[idx]))
        return DEFAULT_VIEW_NUM_GAUGES;

    return settings_view_num_gauges[idx];
}

// Set the Number of gauges
bool set_view_num_gauges(uint8_t idx, uint8_t view_num_gauges, bool save)
{
    // Verify the Number of gauges value is valid
    if (!verify_view_num_gauges(view_num_gauges))
        return false;

    // Check to see if the Number of gauges EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        if (load_view_num_gauges(idx) != view_num_gauges)
        {
            save_view_num_gauges(idx, view_num_gauges);
        }
    }

    settings_view_num_gauges[idx] = view_num_gauges;

    return 1;
}


/********************************************************************************
*                                   Background                                  
*
* @param idx_view    index of the view
* @param background    Set the background color or image of a view by index
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static VIEW_BACKGROUND load_view_background(uint8_t idx)
{
    VIEW_BACKGROUND load_view_background_val = DEFAULT_VIEW_BACKGROUND;

    if (true)
    {
        load_view_background_val = (uint8_t)read(map_view_background_byte1[idx]);
    }
    return load_view_background_val;
}

static void save_view_background(uint8_t idx, VIEW_BACKGROUND view_background)
{
    if (true)
    {
        write(map_view_background_byte1[idx], (uint32_t)view_background & 0xFF);
    }
}

bool verify_view_background(VIEW_BACKGROUND view_background)
{
    if (view_background >= VIEW_BACKGROUND_RESERVED)
        return 0;
    else
        return 1;
}

VIEW_BACKGROUND get_view_background(uint8_t idx)
{
    // Verify the Background value is valid
    if (!verify_view_background(settings_view_background[idx]))
        return DEFAULT_VIEW_BACKGROUND;

    return settings_view_background[idx];
}

// Set the Background
bool set_view_background(uint8_t idx, VIEW_BACKGROUND view_background, bool save)
{
    // Verify the Background value is valid
    if (!verify_view_background(view_background))
        return false;

    // Check to see if the Background EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        if (load_view_background(idx) != view_background)
        {
            save_view_background(idx, view_background);
        }
    }

    settings_view_background[idx] = view_background;

    return 1;
}


/********************************************************************************
*                          Theme assigned to the gauge                          
*
* @param idx_view    index of the view
* @param idx_gauge    index of the gauge
* @param theme    Set the gauge theme by view and gauge index
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static GAUGE_THEME load_view_gauge_theme(uint8_t idx_view, uint8_t idx_gauge)
{
    GAUGE_THEME load_view_gauge_theme_val = DEFAULT_VIEW_GAUGE_THEME;

    if (true)
    {
        load_view_gauge_theme_val = (uint8_t)read(map_view_gauge_theme_byte1[idx_view][idx_gauge]);
    }
    return load_view_gauge_theme_val;
}

static void save_view_gauge_theme(uint8_t idx_view, uint8_t idx_gauge, GAUGE_THEME view_gauge_theme)
{
    if (true)
    {
        write(map_view_gauge_theme_byte1[idx_view][idx_gauge], (uint32_t)view_gauge_theme & 0xFF);
    }
}

bool verify_view_gauge_theme(GAUGE_THEME view_gauge_theme)
{
    if (view_gauge_theme >= GAUGE_THEME_RESERVED)
        return 0;
    else
        return 1;
}

GAUGE_THEME get_view_gauge_theme(uint8_t idx_view, uint8_t idx_gauge)
{
    // Verify the Theme assigned to the gauge value is valid
    if (!verify_view_gauge_theme(settings_view_gauge_theme[idx_view][idx_gauge]))
        return DEFAULT_VIEW_GAUGE_THEME;

    return settings_view_gauge_theme[idx_view][idx_gauge];
}

// Set the Theme assigned to the gauge
bool set_view_gauge_theme(uint8_t idx_view, uint8_t idx_gauge, GAUGE_THEME view_gauge_theme, bool save)
{
    // Verify the Theme assigned to the gauge value is valid
    if (!verify_view_gauge_theme(view_gauge_theme))
        return false;

    // Check to see if the Theme assigned to the gauge EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        if (load_view_gauge_theme(idx_view, idx_gauge) != view_gauge_theme)
        {
            save_view_gauge_theme(idx_view, idx_gauge, view_gauge_theme);
        }
    }

    settings_view_gauge_theme[idx_view][idx_gauge] = view_gauge_theme;

    return 1;
}


/********************************************************************************
*                           PID assigned to the gauge                           
*
* @param idx_view    index of the view
* @param idx_gauge    index of the gauge
* @param pid    Set the gauge PID by view and gauge index
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static uint32_t load_view_gauge_pid(uint8_t idx_view, uint8_t idx_gauge)
{
    uint32_t load_view_gauge_pid_val = DEFAULT_VIEW_GAUGE_PID;

    if (true)
    {
        load_view_gauge_pid_val = (uint32_t)read(map_view_gauge_pid_byte1[idx_view][idx_gauge]);
        load_view_gauge_pid_val = ((uint32_t)load_view_gauge_pid_val << 8) | (uint32_t)read(map_view_gauge_pid_byte2[idx_view][idx_gauge]);
        load_view_gauge_pid_val = ((uint32_t)load_view_gauge_pid_val << 16) | (uint32_t)read(map_view_gauge_pid_byte3[idx_view][idx_gauge]);
        load_view_gauge_pid_val = ((uint32_t)load_view_gauge_pid_val << 24) | (uint32_t)read(map_view_gauge_pid_byte4[idx_view][idx_gauge]);
    }
    return load_view_gauge_pid_val;
}

static void save_view_gauge_pid(uint8_t idx_view, uint8_t idx_gauge, uint32_t view_gauge_pid)
{
    if (true)
    {
        write(map_view_gauge_pid_byte1[idx_view][idx_gauge], ((uint32_t)view_gauge_pid >> 24) & 0xFF);
        write(map_view_gauge_pid_byte2[idx_view][idx_gauge], ((uint32_t)view_gauge_pid >> 16) & 0xFF);
        write(map_view_gauge_pid_byte3[idx_view][idx_gauge], ((uint32_t)view_gauge_pid >> 8) & 0xFF);
        write(map_view_gauge_pid_byte4[idx_view][idx_gauge], (uint32_t)view_gauge_pid & 0xFF);
    }
}

bool verify_view_gauge_pid(uint32_t view_gauge_pid)
{
    if (view_gauge_pid < 1)
        return 0;

    if (view_gauge_pid > 16777215)
        return 0;

    else
        return 1;
}

uint32_t get_view_gauge_pid(uint8_t idx_view, uint8_t idx_gauge)
{
    // Verify the PID assigned to the gauge value is valid
    if (!verify_view_gauge_pid(settings_view_gauge_pid[idx_view][idx_gauge]))
        return DEFAULT_VIEW_GAUGE_PID;

    return settings_view_gauge_pid[idx_view][idx_gauge];
}

// Set the PID assigned to the gauge
bool set_view_gauge_pid(uint8_t idx_view, uint8_t idx_gauge, uint32_t view_gauge_pid, bool save)
{
    // Verify the PID assigned to the gauge value is valid
    if (!verify_view_gauge_pid(view_gauge_pid))
        return false;

    // Check to see if the PID assigned to the gauge EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        if (load_view_gauge_pid(idx_view, idx_gauge) != view_gauge_pid)
        {
            save_view_gauge_pid(idx_view, idx_gauge, view_gauge_pid);
        }
    }

    settings_view_gauge_pid[idx_view][idx_gauge] = view_gauge_pid;

    return 1;
}


/********************************************************************************
*                        PID units assigned to the gauge                        
*
* @param idx_view    index of the view
* @param idx_gauge    index of the gauge
* @param units    Set the PID units by view and gauge index
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static PID_UNITS load_view_gauge_units(uint8_t idx_view, uint8_t idx_gauge)
{
    PID_UNITS load_view_gauge_units_val = DEFAULT_VIEW_GAUGE_UNITS;

    if (true)
    {
        load_view_gauge_units_val = (uint8_t)read(map_view_gauge_units_byte1[idx_view][idx_gauge]);
    }
    return load_view_gauge_units_val;
}

static void save_view_gauge_units(uint8_t idx_view, uint8_t idx_gauge, PID_UNITS view_gauge_units)
{
    if (true)
    {
        write(map_view_gauge_units_byte1[idx_view][idx_gauge], (uint32_t)view_gauge_units & 0xFF);
    }
}

bool verify_view_gauge_units(PID_UNITS view_gauge_units)
{
    if (view_gauge_units < 1)
        return 0;

    if (view_gauge_units > 255)
        return 0;

    else
        return 1;
}

PID_UNITS get_view_gauge_units(uint8_t idx_view, uint8_t idx_gauge)
{
    // Verify the PID units assigned to the gauge value is valid
    if (!verify_view_gauge_units(settings_view_gauge_units[idx_view][idx_gauge]))
        return DEFAULT_VIEW_GAUGE_UNITS;

    return settings_view_gauge_units[idx_view][idx_gauge];
}

// Set the PID units assigned to the gauge
bool set_view_gauge_units(uint8_t idx_view, uint8_t idx_gauge, PID_UNITS view_gauge_units, bool save)
{
    // Verify the PID units assigned to the gauge value is valid
    if (!verify_view_gauge_units(view_gauge_units))
        return false;

    // Check to see if the PID units assigned to the gauge EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        if (load_view_gauge_units(idx_view, idx_gauge) != view_gauge_units)
        {
            save_view_gauge_units(idx_view, idx_gauge, view_gauge_units);
        }
    }

    settings_view_gauge_units[idx_view][idx_gauge] = view_gauge_units;

    return 1;
}


/********************************************************************************
*                                  Alert enable                                 
*
* @param idx_alert    index of the alert
* @param enable    Enable or disable view by index
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static ALERT_STATE load_alert_enable(uint8_t idx)
{
    ALERT_STATE load_alert_enable_val = DEFAULT_ALERT_ENABLE;

    if (true)
    {
        load_alert_enable_val = (uint8_t)read(map_alert_enable_byte1[idx]);
    }
    return load_alert_enable_val;
}

static void save_alert_enable(uint8_t idx, ALERT_STATE alert_enable)
{
    if (true)
    {
        write(map_alert_enable_byte1[idx], (uint32_t)alert_enable & 0xFF);
    }
}

bool verify_alert_enable(ALERT_STATE alert_enable)
{
    if (alert_enable >= ALERT_STATE_RESERVED)
        return 0;
    else
        return 1;
}

ALERT_STATE get_alert_enable(uint8_t idx)
{
    // Verify the Alert enable value is valid
    if (!verify_alert_enable(settings_alert_enable[idx]))
        return DEFAULT_ALERT_ENABLE;

    return settings_alert_enable[idx];
}

// Set the Alert enable
bool set_alert_enable(uint8_t idx, ALERT_STATE alert_enable, bool save)
{
    // Verify the Alert enable value is valid
    if (!verify_alert_enable(alert_enable))
        return false;

    // Check to see if the Alert enable EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        if (load_alert_enable(idx) != alert_enable)
        {
            save_alert_enable(idx, alert_enable);
        }
    }

    settings_alert_enable[idx] = alert_enable;

    return 1;
}


/********************************************************************************
*                                 Alert message                                 
*
* @param idx_alert    index of the alert
* @param message    Set the message that appears when alert occurs
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static char load_alert_message(uint8_t idx)
{
    char load_alert_message_val = DEFAULT_ALERT_MESSAGE;

    return load_alert_message_val;
}

static void save_alert_message(uint8_t idx, char* alert_message)
{
    if (true)
    {
        write(map_alert_message_byte1[idx], alert_message[idx]);
        write(map_alert_message_byte2[idx], alert_message[idx]);
        write(map_alert_message_byte3[idx], alert_message[idx]);
        write(map_alert_message_byte4[idx], alert_message[idx]);
        write(map_alert_message_byte5[idx], alert_message[idx]);
        write(map_alert_message_byte6[idx], alert_message[idx]);
        write(map_alert_message_byte7[idx], alert_message[idx]);
        write(map_alert_message_byte8[idx], alert_message[idx]);
        write(map_alert_message_byte9[idx], alert_message[idx]);
        write(map_alert_message_byte10[idx], alert_message[idx]);
        write(map_alert_message_byte11[idx], alert_message[idx]);
        write(map_alert_message_byte12[idx], alert_message[idx]);
        write(map_alert_message_byte13[idx], alert_message[idx]);
        write(map_alert_message_byte14[idx], alert_message[idx]);
        write(map_alert_message_byte15[idx], alert_message[idx]);
        write(map_alert_message_byte16[idx], alert_message[idx]);
        write(map_alert_message_byte17[idx], alert_message[idx]);
        write(map_alert_message_byte18[idx], alert_message[idx]);
        write(map_alert_message_byte19[idx], alert_message[idx]);
        write(map_alert_message_byte20[idx], alert_message[idx]);
        write(map_alert_message_byte21[idx], alert_message[idx]);
        write(map_alert_message_byte22[idx], alert_message[idx]);
        write(map_alert_message_byte23[idx], alert_message[idx]);
        write(map_alert_message_byte24[idx], alert_message[idx]);
        write(map_alert_message_byte25[idx], alert_message[idx]);
        write(map_alert_message_byte26[idx], alert_message[idx]);
        write(map_alert_message_byte27[idx], alert_message[idx]);
        write(map_alert_message_byte28[idx], alert_message[idx]);
        write(map_alert_message_byte29[idx], alert_message[idx]);
        write(map_alert_message_byte30[idx], alert_message[idx]);
        write(map_alert_message_byte31[idx], alert_message[idx]);
        write(map_alert_message_byte32[idx], alert_message[idx]);
        write(map_alert_message_byte33[idx], alert_message[idx]);
        write(map_alert_message_byte34[idx], alert_message[idx]);
        write(map_alert_message_byte35[idx], alert_message[idx]);
        write(map_alert_message_byte36[idx], alert_message[idx]);
        write(map_alert_message_byte37[idx], alert_message[idx]);
        write(map_alert_message_byte38[idx], alert_message[idx]);
        write(map_alert_message_byte39[idx], alert_message[idx]);
        write(map_alert_message_byte40[idx], alert_message[idx]);
        write(map_alert_message_byte41[idx], alert_message[idx]);
        write(map_alert_message_byte42[idx], alert_message[idx]);
        write(map_alert_message_byte43[idx], alert_message[idx]);
        write(map_alert_message_byte44[idx], alert_message[idx]);
        write(map_alert_message_byte45[idx], alert_message[idx]);
        write(map_alert_message_byte46[idx], alert_message[idx]);
        write(map_alert_message_byte47[idx], alert_message[idx]);
        write(map_alert_message_byte48[idx], alert_message[idx]);
        write(map_alert_message_byte49[idx], alert_message[idx]);
        write(map_alert_message_byte50[idx], alert_message[idx]);
        write(map_alert_message_byte51[idx], alert_message[idx]);
        write(map_alert_message_byte52[idx], alert_message[idx]);
        write(map_alert_message_byte53[idx], alert_message[idx]);
        write(map_alert_message_byte54[idx], alert_message[idx]);
        write(map_alert_message_byte55[idx], alert_message[idx]);
        write(map_alert_message_byte56[idx], alert_message[idx]);
        write(map_alert_message_byte57[idx], alert_message[idx]);
        write(map_alert_message_byte58[idx], alert_message[idx]);
        write(map_alert_message_byte59[idx], alert_message[idx]);
        write(map_alert_message_byte60[idx], alert_message[idx]);
        write(map_alert_message_byte61[idx], alert_message[idx]);
        write(map_alert_message_byte62[idx], alert_message[idx]);
        write(map_alert_message_byte63[idx], alert_message[idx]);
        write(map_alert_message_byte64[idx], alert_message[idx]);
    }
}

bool verify_alert_message(char* alert_message)
{
    return 1; // TODO - String checking
}

void get_alert_message(uint8_t idx, char* alert_message)
{
    memcpy(alert_message, (char)settings_alert_message[idx][0], ALERT_MESSAGE_LEN);
}

// Set the Alert message
bool set_alert_message(uint8_t idx, char* alert_message, bool save)
{
    // Verify the Alert message value is valid
    if (!verify_alert_message(alert_message))
        return false;

    // Check to see if the Alert message EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        if (load_alert_message(idx) != alert_message)
        {
            save_alert_message(idx, alert_message);
        }
    }

    memcpy(settings_alert_message[idx][0], alert_message, ALERT_MESSAGE_LEN);

    return 1;
}


/********************************************************************************
*                                Comparison type                                
*
* @param idx_alert    index of the alert
* @param compare    Configure the comparison used for the realtime value and alert threshold
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static ALERT_COMPARISON load_alert_compare(uint8_t idx)
{
    ALERT_COMPARISON load_alert_compare_val = DEFAULT_ALERT_COMPARE;

    if (true)
    {
        load_alert_compare_val = (uint8_t)read(map_alert_compare_byte1[idx]);
    }
    return load_alert_compare_val;
}

static void save_alert_compare(uint8_t idx, ALERT_COMPARISON alert_compare)
{
    if (true)
    {
        write(map_alert_compare_byte1[idx], (uint32_t)alert_compare & 0xFF);
    }
}

bool verify_alert_compare(ALERT_COMPARISON alert_compare)
{
    if (alert_compare >= ALERT_COMPARISON_RESERVED)
        return 0;
    else
        return 1;
}

ALERT_COMPARISON get_alert_compare(uint8_t idx)
{
    // Verify the Comparison type value is valid
    if (!verify_alert_compare(settings_alert_compare[idx]))
        return DEFAULT_ALERT_COMPARE;

    return settings_alert_compare[idx];
}

// Set the Comparison type
bool set_alert_compare(uint8_t idx, ALERT_COMPARISON alert_compare, bool save)
{
    // Verify the Comparison type value is valid
    if (!verify_alert_compare(alert_compare))
        return false;

    // Check to see if the Comparison type EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        if (load_alert_compare(idx) != alert_compare)
        {
            save_alert_compare(idx, alert_compare);
        }
    }

    settings_alert_compare[idx] = alert_compare;

    return 1;
}


/********************************************************************************
*                            Dynamic gauge threshold                            
*
* @param idx_alert    index of the alert
* @param threshold    Comparison value of the dynamic gauge
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static float load_alert_threshold(uint8_t idx)
{
    float load_alert_threshold_val = DEFAULT_ALERT_THRESHOLD;

    if (true)
    {
        load_alert_threshold_val = (uint32_t)read(map_alert_threshold_byte1[idx]);
        load_alert_threshold_val = ((uint32_t)load_alert_threshold_val << 8) | (uint32_t)read(map_alert_threshold_byte2[idx]);
        load_alert_threshold_val = ((uint32_t)load_alert_threshold_val << 16) | (uint32_t)read(map_alert_threshold_byte3[idx]);
        load_alert_threshold_val = ((uint32_t)load_alert_threshold_val << 24) | (uint32_t)read(map_alert_threshold_byte4[idx]);
    }
    return load_alert_threshold_val;
}

static void save_alert_threshold(uint8_t idx, float alert_threshold)
{
    if (true)
    {
        write(map_alert_threshold_byte1[idx], ((uint32_t)alert_threshold >> 24) & 0xFF);
        write(map_alert_threshold_byte2[idx], ((uint32_t)alert_threshold >> 16) & 0xFF);
        write(map_alert_threshold_byte3[idx], ((uint32_t)alert_threshold >> 8) & 0xFF);
        write(map_alert_threshold_byte4[idx], (uint32_t)alert_threshold & 0xFF);
    }
}

bool verify_alert_threshold(float alert_threshold)
{
    if (alert_threshold < -100000)
        return 0;

    if (alert_threshold > 100000)
        return 0;

    else
        return 1;
}

float get_alert_threshold(uint8_t idx)
{
    // Verify the Dynamic gauge threshold value is valid
    if (!verify_alert_threshold(settings_alert_threshold[idx]))
        return DEFAULT_ALERT_THRESHOLD;

    return settings_alert_threshold[idx];
}

// Set the Dynamic gauge threshold
bool set_alert_threshold(uint8_t idx, float alert_threshold, bool save)
{
    // Verify the Dynamic gauge threshold value is valid
    if (!verify_alert_threshold(alert_threshold))
        return false;

    // Check to see if the Dynamic gauge threshold EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        if (load_alert_threshold(idx) != alert_threshold)
        {
            save_alert_threshold(idx, alert_threshold);
        }
    }

    settings_alert_threshold[idx] = alert_threshold;

    return 1;
}


/********************************************************************************
*                                 Dynamic enable                                
*
* @param idx_dynamic    index of the dynamic
* @param enable    Enable or disable view by index
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static DYNAMIC_STATE load_dynamic_enable(uint8_t idx)
{
    DYNAMIC_STATE load_dynamic_enable_val = DEFAULT_DYNAMIC_ENABLE;

    if (true)
    {
        load_dynamic_enable_val = (uint8_t)read(map_dynamic_enable_byte1[idx]);
    }
    return load_dynamic_enable_val;
}

static void save_dynamic_enable(uint8_t idx, DYNAMIC_STATE dynamic_enable)
{
    if (true)
    {
        write(map_dynamic_enable_byte1[idx], (uint32_t)dynamic_enable & 0xFF);
    }
}

bool verify_dynamic_enable(DYNAMIC_STATE dynamic_enable)
{
    if (dynamic_enable >= DYNAMIC_STATE_RESERVED)
        return 0;
    else
        return 1;
}

DYNAMIC_STATE get_dynamic_enable(uint8_t idx)
{
    // Verify the Dynamic enable value is valid
    if (!verify_dynamic_enable(settings_dynamic_enable[idx]))
        return DEFAULT_DYNAMIC_ENABLE;

    return settings_dynamic_enable[idx];
}

// Set the Dynamic enable
bool set_dynamic_enable(uint8_t idx, DYNAMIC_STATE dynamic_enable, bool save)
{
    // Verify the Dynamic enable value is valid
    if (!verify_dynamic_enable(dynamic_enable))
        return false;

    // Check to see if the Dynamic enable EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        if (load_dynamic_enable(idx) != dynamic_enable)
        {
            save_dynamic_enable(idx, dynamic_enable);
        }
    }

    settings_dynamic_enable[idx] = dynamic_enable;

    return 1;
}


/********************************************************************************
*                                    Priority                                   
*
* @param idx_dynamic    index of the dynamic
* @param priority    Priority of the dynamic gauges, if both gauges comparisons are met then highest priority wins
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static DYNAMIC_PRIORITY load_dynamic_priority(uint8_t idx)
{
    DYNAMIC_PRIORITY load_dynamic_priority_val = DEFAULT_DYNAMIC_PRIORITY;

    if (true)
    {
        load_dynamic_priority_val = (uint8_t)read(map_dynamic_priority_byte1[idx]);
    }
    return load_dynamic_priority_val;
}

static void save_dynamic_priority(uint8_t idx, DYNAMIC_PRIORITY dynamic_priority)
{
    if (true)
    {
        write(map_dynamic_priority_byte1[idx], (uint32_t)dynamic_priority & 0xFF);
    }
}

bool verify_dynamic_priority(DYNAMIC_PRIORITY dynamic_priority)
{
    if (dynamic_priority >= DYNAMIC_PRIORITY_RESERVED)
        return 0;
    else
        return 1;
}

DYNAMIC_PRIORITY get_dynamic_priority(uint8_t idx)
{
    // Verify the Priority value is valid
    if (!verify_dynamic_priority(settings_dynamic_priority[idx]))
        return DEFAULT_DYNAMIC_PRIORITY;

    return settings_dynamic_priority[idx];
}

// Set the Priority
bool set_dynamic_priority(uint8_t idx, DYNAMIC_PRIORITY dynamic_priority, bool save)
{
    // Verify the Priority value is valid
    if (!verify_dynamic_priority(dynamic_priority))
        return false;

    // Check to see if the Priority EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        if (load_dynamic_priority(idx) != dynamic_priority)
        {
            save_dynamic_priority(idx, dynamic_priority);
        }
    }

    settings_dynamic_priority[idx] = dynamic_priority;

    return 1;
}


/********************************************************************************
*                                Comparison type                                
*
* @param idx_dynamic    index of the dynamic
* @param compare    Configure the comparison used for the realtime value and alert threshold
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static DYNAMIC_COMPARISON load_dynamic_compare(uint8_t idx)
{
    DYNAMIC_COMPARISON load_dynamic_compare_val = DEFAULT_DYNAMIC_COMPARE;

    if (true)
    {
        load_dynamic_compare_val = (uint8_t)read(map_dynamic_compare_byte1[idx]);
    }
    return load_dynamic_compare_val;
}

static void save_dynamic_compare(uint8_t idx, DYNAMIC_COMPARISON dynamic_compare)
{
    if (true)
    {
        write(map_dynamic_compare_byte1[idx], (uint32_t)dynamic_compare & 0xFF);
    }
}

bool verify_dynamic_compare(DYNAMIC_COMPARISON dynamic_compare)
{
    if (dynamic_compare >= DYNAMIC_COMPARISON_RESERVED)
        return 0;
    else
        return 1;
}

DYNAMIC_COMPARISON get_dynamic_compare(uint8_t idx)
{
    // Verify the Comparison type value is valid
    if (!verify_dynamic_compare(settings_dynamic_compare[idx]))
        return DEFAULT_DYNAMIC_COMPARE;

    return settings_dynamic_compare[idx];
}

// Set the Comparison type
bool set_dynamic_compare(uint8_t idx, DYNAMIC_COMPARISON dynamic_compare, bool save)
{
    // Verify the Comparison type value is valid
    if (!verify_dynamic_compare(dynamic_compare))
        return false;

    // Check to see if the Comparison type EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        if (load_dynamic_compare(idx) != dynamic_compare)
        {
            save_dynamic_compare(idx, dynamic_compare);
        }
    }

    settings_dynamic_compare[idx] = dynamic_compare;

    return 1;
}


/********************************************************************************
*                            Dynamic gauge threshold                            
*
* @param idx_dynamic    index of the dynamic
* @param Threshold    Comparison value of the dynamic gauge
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static float load_dynamic_threshold(uint8_t idx)
{
    float load_dynamic_threshold_val = DEFAULT_DYNAMIC_THRESHOLD;

    if (true)
    {
        load_dynamic_threshold_val = (uint32_t)read(map_dynamic_threshold_byte1[idx]);
        load_dynamic_threshold_val = ((uint32_t)load_dynamic_threshold_val << 8) | (uint32_t)read(map_dynamic_threshold_byte2[idx]);
        load_dynamic_threshold_val = ((uint32_t)load_dynamic_threshold_val << 16) | (uint32_t)read(map_dynamic_threshold_byte3[idx]);
        load_dynamic_threshold_val = ((uint32_t)load_dynamic_threshold_val << 24) | (uint32_t)read(map_dynamic_threshold_byte4[idx]);
    }
    return load_dynamic_threshold_val;
}

static void save_dynamic_threshold(uint8_t idx, float dynamic_threshold)
{
    if (true)
    {
        write(map_dynamic_threshold_byte1[idx], ((uint32_t)dynamic_threshold >> 24) & 0xFF);
        write(map_dynamic_threshold_byte2[idx], ((uint32_t)dynamic_threshold >> 16) & 0xFF);
        write(map_dynamic_threshold_byte3[idx], ((uint32_t)dynamic_threshold >> 8) & 0xFF);
        write(map_dynamic_threshold_byte4[idx], (uint32_t)dynamic_threshold & 0xFF);
    }
}

bool verify_dynamic_threshold(float dynamic_threshold)
{
    if (dynamic_threshold < -100000)
        return 0;

    if (dynamic_threshold > 100000)
        return 0;

    else
        return 1;
}

float get_dynamic_threshold(uint8_t idx)
{
    // Verify the Dynamic gauge threshold value is valid
    if (!verify_dynamic_threshold(settings_dynamic_threshold[idx]))
        return DEFAULT_DYNAMIC_THRESHOLD;

    return settings_dynamic_threshold[idx];
}

// Set the Dynamic gauge threshold
bool set_dynamic_threshold(uint8_t idx, float dynamic_threshold, bool save)
{
    // Verify the Dynamic gauge threshold value is valid
    if (!verify_dynamic_threshold(dynamic_threshold))
        return false;

    // Check to see if the Dynamic gauge threshold EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        if (load_dynamic_threshold(idx) != dynamic_threshold)
        {
            save_dynamic_threshold(idx, dynamic_threshold);
        }
    }

    settings_dynamic_threshold[idx] = dynamic_threshold;

    return 1;
}


/********************************************************************************
*                                   View index                                  
*
* @param idx_dynamic    index of the dynamic
* @param Index    Set which view should be enabled if the dynamic event is true
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static uint8_t load_dynamic_index(uint8_t idx)
{
    uint8_t load_dynamic_index_val = DEFAULT_DYNAMIC_INDEX;

    if (true)
    {
        load_dynamic_index_val = (uint8_t)read(map_dynamic_index_byte1[idx]);
    }
    return load_dynamic_index_val;
}

static void save_dynamic_index(uint8_t idx, uint8_t dynamic_index)
{
    if (true)
    {
        write(map_dynamic_index_byte1[idx], (uint32_t)dynamic_index & 0xFF);
    }
}

bool verify_dynamic_index(uint8_t dynamic_index)
{
    if (dynamic_index > MAX_VIEWS)
        return 0;

    else
        return 1;
}

uint8_t get_dynamic_index(uint8_t idx)
{
    // Verify the View index value is valid
    if (!verify_dynamic_index(settings_dynamic_index[idx]))
        return DEFAULT_DYNAMIC_INDEX;

    return settings_dynamic_index[idx];
}

// Set the View index
bool set_dynamic_index(uint8_t idx, uint8_t dynamic_index, bool save)
{
    // Verify the View index value is valid
    if (!verify_dynamic_index(dynamic_index))
        return false;

    // Check to see if the View index EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        if (load_dynamic_index(idx) != dynamic_index)
        {
            save_dynamic_index(idx, dynamic_index);
        }
    }

    settings_dynamic_index[idx] = dynamic_index;

    return 1;
}
