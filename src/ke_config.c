/**
 ******************************************************************************
 *
 * Copyright (c) 2025 KaiserEngineering, LLC
 * Author Matthew Kaiser
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 ******************************************************************************
 */

#include "ke_config.h"

#define DEFAULT_VIEW_ENABLE VIEW_STATE_DISABLED
#define DEFAULT_VIEW_NUM_GAUGES 0
#define DEFAULT_VIEW_BACKGROUND VIEW_BACKGROUND_BLACK
#define DEFAULT_VIEW_GAUGE_THEME GAUGE_THEME_STOCK_ST
#define DEFAULT_VIEW_GAUGE_PID 0
#define DEFAULT_VIEW_GAUGE_UNITS PID_UNITS_RESERVED
#define DEFAULT_ALERT_ENABLE ALERT_STATE_DISABLED
#define DEFAULT_ALERT_PID 0
#define DEFAULT_ALERT_UNITS PID_UNITS_RESERVED
#define DEFAULT_ALERT_MESSAGE 0
#define DEFAULT_ALERT_COMPARE ALERT_COMPARISON_GREATER_THAN
#define DEFAULT_ALERT_THRESHOLD 0
#define DEFAULT_DYNAMIC_ENABLE DYNAMIC_STATE_DISABLED
#define DEFAULT_DYNAMIC_PRIORITY DYNAMIC_PRIORITY_LOW
#define DEFAULT_DYNAMIC_COMPARE DYNAMIC_COMPARISON_GREATER_THAN
#define DEFAULT_DYNAMIC_THRESHOLD 0
#define DEFAULT_DYNAMIC_INDEX 0
#define DEFAULT_DYNAMIC_PID 0
#define DEFAULT_DYNAMIC_UNITS PID_UNITS_RESERVED

#define EE_SIZE_VIEW_ENABLE 1
#define EE_SIZE_VIEW_NUM_GAUGES 1
#define EE_SIZE_VIEW_BACKGROUND 1
#define EE_SIZE_VIEW_GAUGE_THEME 1
#define EE_SIZE_VIEW_GAUGE_PID 4
#define EE_SIZE_VIEW_GAUGE_UNITS 1
#define EE_SIZE_ALERT_ENABLE 1
#define EE_SIZE_ALERT_PID 4
#define EE_SIZE_ALERT_UNITS 1
#define EE_SIZE_ALERT_MESSAGE ALERT_MESSAGE_LEN
#define EE_SIZE_ALERT_COMPARE 1
#define EE_SIZE_ALERT_THRESHOLD 4
#define EE_SIZE_DYNAMIC_ENABLE 1
#define EE_SIZE_DYNAMIC_PRIORITY 1
#define EE_SIZE_DYNAMIC_COMPARE 1
#define EE_SIZE_DYNAMIC_THRESHOLD 4
#define EE_SIZE_DYNAMIC_INDEX 1
#define EE_SIZE_DYNAMIC_PID 4
#define EE_SIZE_DYNAMIC_UNITS 1

// EEPROM Memory Map - view enable
#define EEPROM_VIEW_ENABLE1_BYTE1 (uint16_t)0x0000
#define EEPROM_VIEW_ENABLE2_BYTE1 (uint16_t)0x0001
#define EEPROM_VIEW_ENABLE3_BYTE1 (uint16_t)0x0002
static const uint16_t map_view_enable_byte1[MAX_VIEWS] = {
    EEPROM_VIEW_ENABLE1_BYTE1,
    EEPROM_VIEW_ENABLE2_BYTE1,
    EEPROM_VIEW_ENABLE3_BYTE1
    };

// EEPROM Memory Map - view num_gauges
#define EEPROM_VIEW_NUM_GAUGES1_BYTE1 (uint16_t)0x0003
#define EEPROM_VIEW_NUM_GAUGES2_BYTE1 (uint16_t)0x0004
#define EEPROM_VIEW_NUM_GAUGES3_BYTE1 (uint16_t)0x0005
static const uint16_t map_view_num_gauges_byte1[MAX_GAUGES_PER_VIEW] = {
    EEPROM_VIEW_NUM_GAUGES1_BYTE1,
    EEPROM_VIEW_NUM_GAUGES2_BYTE1,
    EEPROM_VIEW_NUM_GAUGES3_BYTE1
    };

// EEPROM Memory Map - view background
#define EEPROM_VIEW_BACKGROUND1_BYTE1 (uint16_t)0x0006
#define EEPROM_VIEW_BACKGROUND2_BYTE1 (uint16_t)0x0007
#define EEPROM_VIEW_BACKGROUND3_BYTE1 (uint16_t)0x0008
static const uint16_t map_view_background_byte1[MAX_VIEWS] = {
    EEPROM_VIEW_BACKGROUND1_BYTE1,
    EEPROM_VIEW_BACKGROUND2_BYTE1,
    EEPROM_VIEW_BACKGROUND3_BYTE1
    };

// EEPROM Memory Map - view_gauge theme
#define EEPROM_VIEW1_GAUGE_THEME1_BYTE1 (uint16_t)0x0009
#define EEPROM_VIEW1_GAUGE_THEME2_BYTE1 (uint16_t)0x000A
#define EEPROM_VIEW1_GAUGE_THEME3_BYTE1 (uint16_t)0x000B
#define EEPROM_VIEW2_GAUGE_THEME1_BYTE1 (uint16_t)0x000C
#define EEPROM_VIEW2_GAUGE_THEME2_BYTE1 (uint16_t)0x000D
#define EEPROM_VIEW2_GAUGE_THEME3_BYTE1 (uint16_t)0x000E
#define EEPROM_VIEW3_GAUGE_THEME1_BYTE1 (uint16_t)0x000F
#define EEPROM_VIEW3_GAUGE_THEME2_BYTE1 (uint16_t)0x0010
#define EEPROM_VIEW3_GAUGE_THEME3_BYTE1 (uint16_t)0x0011
#define EEPROM_VIEW1_GAUGE_THEME_BYTE1 {EEPROM_VIEW1_GAUGE_THEME1_BYTE1, EEPROM_VIEW1_GAUGE_THEME2_BYTE1, EEPROM_VIEW1_GAUGE_THEME3_BYTE1}
#define EEPROM_VIEW2_GAUGE_THEME_BYTE1 {EEPROM_VIEW2_GAUGE_THEME1_BYTE1, EEPROM_VIEW2_GAUGE_THEME2_BYTE1, EEPROM_VIEW2_GAUGE_THEME3_BYTE1}
#define EEPROM_VIEW3_GAUGE_THEME_BYTE1 {EEPROM_VIEW3_GAUGE_THEME1_BYTE1, EEPROM_VIEW3_GAUGE_THEME2_BYTE1, EEPROM_VIEW3_GAUGE_THEME3_BYTE1}
static const uint16_t map_view_gauge_theme_byte1[MAX_VIEWS][MAX_GAUGES_PER_VIEW] = {
    EEPROM_VIEW1_GAUGE_THEME_BYTE1,
    EEPROM_VIEW2_GAUGE_THEME_BYTE1,
    EEPROM_VIEW3_GAUGE_THEME_BYTE1
    };

// EEPROM Memory Map - view_gauge pid
#define EEPROM_VIEW1_GAUGE_PID1_BYTE1 (uint16_t)0x0012
#define EEPROM_VIEW1_GAUGE_PID1_BYTE2 (uint16_t)0x0013
#define EEPROM_VIEW1_GAUGE_PID1_BYTE3 (uint16_t)0x0014
#define EEPROM_VIEW1_GAUGE_PID1_BYTE4 (uint16_t)0x0015
#define EEPROM_VIEW1_GAUGE_PID2_BYTE1 (uint16_t)0x0016
#define EEPROM_VIEW1_GAUGE_PID2_BYTE2 (uint16_t)0x0017
#define EEPROM_VIEW1_GAUGE_PID2_BYTE3 (uint16_t)0x0018
#define EEPROM_VIEW1_GAUGE_PID2_BYTE4 (uint16_t)0x0019
#define EEPROM_VIEW1_GAUGE_PID3_BYTE1 (uint16_t)0x001A
#define EEPROM_VIEW1_GAUGE_PID3_BYTE2 (uint16_t)0x001B
#define EEPROM_VIEW1_GAUGE_PID3_BYTE3 (uint16_t)0x001C
#define EEPROM_VIEW1_GAUGE_PID3_BYTE4 (uint16_t)0x001D
#define EEPROM_VIEW2_GAUGE_PID1_BYTE1 (uint16_t)0x001E
#define EEPROM_VIEW2_GAUGE_PID1_BYTE2 (uint16_t)0x001F
#define EEPROM_VIEW2_GAUGE_PID1_BYTE3 (uint16_t)0x0020
#define EEPROM_VIEW2_GAUGE_PID1_BYTE4 (uint16_t)0x0021
#define EEPROM_VIEW2_GAUGE_PID2_BYTE1 (uint16_t)0x0022
#define EEPROM_VIEW2_GAUGE_PID2_BYTE2 (uint16_t)0x0023
#define EEPROM_VIEW2_GAUGE_PID2_BYTE3 (uint16_t)0x0024
#define EEPROM_VIEW2_GAUGE_PID2_BYTE4 (uint16_t)0x0025
#define EEPROM_VIEW2_GAUGE_PID3_BYTE1 (uint16_t)0x0026
#define EEPROM_VIEW2_GAUGE_PID3_BYTE2 (uint16_t)0x0027
#define EEPROM_VIEW2_GAUGE_PID3_BYTE3 (uint16_t)0x0028
#define EEPROM_VIEW2_GAUGE_PID3_BYTE4 (uint16_t)0x0029
#define EEPROM_VIEW3_GAUGE_PID1_BYTE1 (uint16_t)0x002A
#define EEPROM_VIEW3_GAUGE_PID1_BYTE2 (uint16_t)0x002B
#define EEPROM_VIEW3_GAUGE_PID1_BYTE3 (uint16_t)0x002C
#define EEPROM_VIEW3_GAUGE_PID1_BYTE4 (uint16_t)0x002D
#define EEPROM_VIEW3_GAUGE_PID2_BYTE1 (uint16_t)0x002E
#define EEPROM_VIEW3_GAUGE_PID2_BYTE2 (uint16_t)0x002F
#define EEPROM_VIEW3_GAUGE_PID2_BYTE3 (uint16_t)0x0030
#define EEPROM_VIEW3_GAUGE_PID2_BYTE4 (uint16_t)0x0031
#define EEPROM_VIEW3_GAUGE_PID3_BYTE1 (uint16_t)0x0032
#define EEPROM_VIEW3_GAUGE_PID3_BYTE2 (uint16_t)0x0033
#define EEPROM_VIEW3_GAUGE_PID3_BYTE3 (uint16_t)0x0034
#define EEPROM_VIEW3_GAUGE_PID3_BYTE4 (uint16_t)0x0035
#define EEPROM_VIEW1_GAUGE_PID_BYTE1 {EEPROM_VIEW1_GAUGE_PID1_BYTE1, EEPROM_VIEW1_GAUGE_PID2_BYTE1, EEPROM_VIEW1_GAUGE_PID3_BYTE1}
#define EEPROM_VIEW2_GAUGE_PID_BYTE1 {EEPROM_VIEW2_GAUGE_PID1_BYTE1, EEPROM_VIEW2_GAUGE_PID2_BYTE1, EEPROM_VIEW2_GAUGE_PID3_BYTE1}
#define EEPROM_VIEW3_GAUGE_PID_BYTE1 {EEPROM_VIEW3_GAUGE_PID1_BYTE1, EEPROM_VIEW3_GAUGE_PID2_BYTE1, EEPROM_VIEW3_GAUGE_PID3_BYTE1}
static const uint16_t map_view_gauge_pid_byte1[MAX_VIEWS][MAX_GAUGES_PER_VIEW] = {
    EEPROM_VIEW1_GAUGE_PID_BYTE1,
    EEPROM_VIEW2_GAUGE_PID_BYTE1,
    EEPROM_VIEW3_GAUGE_PID_BYTE1
    };

#define EEPROM_VIEW1_GAUGE_PID_BYTE2 {EEPROM_VIEW1_GAUGE_PID1_BYTE2, EEPROM_VIEW1_GAUGE_PID2_BYTE2, EEPROM_VIEW1_GAUGE_PID3_BYTE2}
#define EEPROM_VIEW2_GAUGE_PID_BYTE2 {EEPROM_VIEW2_GAUGE_PID1_BYTE2, EEPROM_VIEW2_GAUGE_PID2_BYTE2, EEPROM_VIEW2_GAUGE_PID3_BYTE2}
#define EEPROM_VIEW3_GAUGE_PID_BYTE2 {EEPROM_VIEW3_GAUGE_PID1_BYTE2, EEPROM_VIEW3_GAUGE_PID2_BYTE2, EEPROM_VIEW3_GAUGE_PID3_BYTE2}
static const uint16_t map_view_gauge_pid_byte2[MAX_VIEWS][MAX_GAUGES_PER_VIEW] = {
    EEPROM_VIEW1_GAUGE_PID_BYTE2,
    EEPROM_VIEW2_GAUGE_PID_BYTE2,
    EEPROM_VIEW3_GAUGE_PID_BYTE2
    };

#define EEPROM_VIEW1_GAUGE_PID_BYTE3 {EEPROM_VIEW1_GAUGE_PID1_BYTE3, EEPROM_VIEW1_GAUGE_PID2_BYTE3, EEPROM_VIEW1_GAUGE_PID3_BYTE3}
#define EEPROM_VIEW2_GAUGE_PID_BYTE3 {EEPROM_VIEW2_GAUGE_PID1_BYTE3, EEPROM_VIEW2_GAUGE_PID2_BYTE3, EEPROM_VIEW2_GAUGE_PID3_BYTE3}
#define EEPROM_VIEW3_GAUGE_PID_BYTE3 {EEPROM_VIEW3_GAUGE_PID1_BYTE3, EEPROM_VIEW3_GAUGE_PID2_BYTE3, EEPROM_VIEW3_GAUGE_PID3_BYTE3}
static const uint16_t map_view_gauge_pid_byte3[MAX_VIEWS][MAX_GAUGES_PER_VIEW] = {
    EEPROM_VIEW1_GAUGE_PID_BYTE3,
    EEPROM_VIEW2_GAUGE_PID_BYTE3,
    EEPROM_VIEW3_GAUGE_PID_BYTE3
    };

#define EEPROM_VIEW1_GAUGE_PID_BYTE4 {EEPROM_VIEW1_GAUGE_PID1_BYTE4, EEPROM_VIEW1_GAUGE_PID2_BYTE4, EEPROM_VIEW1_GAUGE_PID3_BYTE4}
#define EEPROM_VIEW2_GAUGE_PID_BYTE4 {EEPROM_VIEW2_GAUGE_PID1_BYTE4, EEPROM_VIEW2_GAUGE_PID2_BYTE4, EEPROM_VIEW2_GAUGE_PID3_BYTE4}
#define EEPROM_VIEW3_GAUGE_PID_BYTE4 {EEPROM_VIEW3_GAUGE_PID1_BYTE4, EEPROM_VIEW3_GAUGE_PID2_BYTE4, EEPROM_VIEW3_GAUGE_PID3_BYTE4}
static const uint16_t map_view_gauge_pid_byte4[MAX_VIEWS][MAX_GAUGES_PER_VIEW] = {
    EEPROM_VIEW1_GAUGE_PID_BYTE4,
    EEPROM_VIEW2_GAUGE_PID_BYTE4,
    EEPROM_VIEW3_GAUGE_PID_BYTE4
    };

// EEPROM Memory Map - view_gauge units
#define EEPROM_VIEW1_GAUGE_UNITS1_BYTE1 (uint16_t)0x0036
#define EEPROM_VIEW1_GAUGE_UNITS2_BYTE1 (uint16_t)0x0037
#define EEPROM_VIEW1_GAUGE_UNITS3_BYTE1 (uint16_t)0x0038
#define EEPROM_VIEW2_GAUGE_UNITS1_BYTE1 (uint16_t)0x0039
#define EEPROM_VIEW2_GAUGE_UNITS2_BYTE1 (uint16_t)0x003A
#define EEPROM_VIEW2_GAUGE_UNITS3_BYTE1 (uint16_t)0x003B
#define EEPROM_VIEW3_GAUGE_UNITS1_BYTE1 (uint16_t)0x003C
#define EEPROM_VIEW3_GAUGE_UNITS2_BYTE1 (uint16_t)0x003D
#define EEPROM_VIEW3_GAUGE_UNITS3_BYTE1 (uint16_t)0x003E
#define EEPROM_VIEW1_GAUGE_UNITS_BYTE1 {EEPROM_VIEW1_GAUGE_UNITS1_BYTE1, EEPROM_VIEW1_GAUGE_UNITS2_BYTE1, EEPROM_VIEW1_GAUGE_UNITS3_BYTE1}
#define EEPROM_VIEW2_GAUGE_UNITS_BYTE1 {EEPROM_VIEW2_GAUGE_UNITS1_BYTE1, EEPROM_VIEW2_GAUGE_UNITS2_BYTE1, EEPROM_VIEW2_GAUGE_UNITS3_BYTE1}
#define EEPROM_VIEW3_GAUGE_UNITS_BYTE1 {EEPROM_VIEW3_GAUGE_UNITS1_BYTE1, EEPROM_VIEW3_GAUGE_UNITS2_BYTE1, EEPROM_VIEW3_GAUGE_UNITS3_BYTE1}
static const uint16_t map_view_gauge_units_byte1[MAX_VIEWS][MAX_GAUGES_PER_VIEW] = {
    EEPROM_VIEW1_GAUGE_UNITS_BYTE1,
    EEPROM_VIEW2_GAUGE_UNITS_BYTE1,
    EEPROM_VIEW3_GAUGE_UNITS_BYTE1
    };

// EEPROM Memory Map - alert enable
#define EEPROM_ALERT_ENABLE1_BYTE1 (uint16_t)0x003F
#define EEPROM_ALERT_ENABLE2_BYTE1 (uint16_t)0x0040
#define EEPROM_ALERT_ENABLE3_BYTE1 (uint16_t)0x0041
#define EEPROM_ALERT_ENABLE4_BYTE1 (uint16_t)0x0042
#define EEPROM_ALERT_ENABLE5_BYTE1 (uint16_t)0x0043
static const uint16_t map_alert_enable_byte1[MAX_ALERTS] = {
    EEPROM_ALERT_ENABLE1_BYTE1,
    EEPROM_ALERT_ENABLE2_BYTE1,
    EEPROM_ALERT_ENABLE3_BYTE1,
    EEPROM_ALERT_ENABLE4_BYTE1,
    EEPROM_ALERT_ENABLE5_BYTE1
    };

// EEPROM Memory Map - alert pid
#define EEPROM_ALERT_PID1_BYTE1 (uint16_t)0x0044
#define EEPROM_ALERT_PID1_BYTE2 (uint16_t)0x0045
#define EEPROM_ALERT_PID1_BYTE3 (uint16_t)0x0046
#define EEPROM_ALERT_PID1_BYTE4 (uint16_t)0x0047
#define EEPROM_ALERT_PID2_BYTE1 (uint16_t)0x0048
#define EEPROM_ALERT_PID2_BYTE2 (uint16_t)0x0049
#define EEPROM_ALERT_PID2_BYTE3 (uint16_t)0x004A
#define EEPROM_ALERT_PID2_BYTE4 (uint16_t)0x004B
#define EEPROM_ALERT_PID3_BYTE1 (uint16_t)0x004C
#define EEPROM_ALERT_PID3_BYTE2 (uint16_t)0x004D
#define EEPROM_ALERT_PID3_BYTE3 (uint16_t)0x004E
#define EEPROM_ALERT_PID3_BYTE4 (uint16_t)0x004F
#define EEPROM_ALERT_PID4_BYTE1 (uint16_t)0x0050
#define EEPROM_ALERT_PID4_BYTE2 (uint16_t)0x0051
#define EEPROM_ALERT_PID4_BYTE3 (uint16_t)0x0052
#define EEPROM_ALERT_PID4_BYTE4 (uint16_t)0x0053
#define EEPROM_ALERT_PID5_BYTE1 (uint16_t)0x0054
#define EEPROM_ALERT_PID5_BYTE2 (uint16_t)0x0055
#define EEPROM_ALERT_PID5_BYTE3 (uint16_t)0x0056
#define EEPROM_ALERT_PID5_BYTE4 (uint16_t)0x0057
static const uint16_t map_alert_pid_byte1[MAX_ALERTS] = {
    EEPROM_ALERT_PID1_BYTE1,
    EEPROM_ALERT_PID2_BYTE1,
    EEPROM_ALERT_PID3_BYTE1,
    EEPROM_ALERT_PID4_BYTE1,
    EEPROM_ALERT_PID5_BYTE1
    };

static const uint16_t map_alert_pid_byte2[MAX_ALERTS] = {
    EEPROM_ALERT_PID1_BYTE2,
    EEPROM_ALERT_PID2_BYTE2,
    EEPROM_ALERT_PID3_BYTE2,
    EEPROM_ALERT_PID4_BYTE2,
    EEPROM_ALERT_PID5_BYTE2
    };

static const uint16_t map_alert_pid_byte3[MAX_ALERTS] = {
    EEPROM_ALERT_PID1_BYTE3,
    EEPROM_ALERT_PID2_BYTE3,
    EEPROM_ALERT_PID3_BYTE3,
    EEPROM_ALERT_PID4_BYTE3,
    EEPROM_ALERT_PID5_BYTE3
    };

static const uint16_t map_alert_pid_byte4[MAX_ALERTS] = {
    EEPROM_ALERT_PID1_BYTE4,
    EEPROM_ALERT_PID2_BYTE4,
    EEPROM_ALERT_PID3_BYTE4,
    EEPROM_ALERT_PID4_BYTE4,
    EEPROM_ALERT_PID5_BYTE4
    };

// EEPROM Memory Map - alert units
#define EEPROM_ALERT_UNITS1_BYTE1 (uint16_t)0x0058
#define EEPROM_ALERT_UNITS2_BYTE1 (uint16_t)0x0059
#define EEPROM_ALERT_UNITS3_BYTE1 (uint16_t)0x005A
#define EEPROM_ALERT_UNITS4_BYTE1 (uint16_t)0x005B
#define EEPROM_ALERT_UNITS5_BYTE1 (uint16_t)0x005C
static const uint16_t map_alert_units_byte1[MAX_ALERTS] = {
    EEPROM_ALERT_UNITS1_BYTE1,
    EEPROM_ALERT_UNITS2_BYTE1,
    EEPROM_ALERT_UNITS3_BYTE1,
    EEPROM_ALERT_UNITS4_BYTE1,
    EEPROM_ALERT_UNITS5_BYTE1
    };

// EEPROM Memory Map - alert message
#define EEPROM_ALERT_MESSAGE1_BYTE1 (uint16_t)0x005D
#define EEPROM_ALERT_MESSAGE1_BYTE2 (uint16_t)0x005E
#define EEPROM_ALERT_MESSAGE1_BYTE3 (uint16_t)0x005F
#define EEPROM_ALERT_MESSAGE1_BYTE4 (uint16_t)0x0060
#define EEPROM_ALERT_MESSAGE1_BYTE5 (uint16_t)0x0061
#define EEPROM_ALERT_MESSAGE1_BYTE6 (uint16_t)0x0062
#define EEPROM_ALERT_MESSAGE1_BYTE7 (uint16_t)0x0063
#define EEPROM_ALERT_MESSAGE1_BYTE8 (uint16_t)0x0064
#define EEPROM_ALERT_MESSAGE1_BYTE9 (uint16_t)0x0065
#define EEPROM_ALERT_MESSAGE1_BYTE10 (uint16_t)0x0066
#define EEPROM_ALERT_MESSAGE1_BYTE11 (uint16_t)0x0067
#define EEPROM_ALERT_MESSAGE1_BYTE12 (uint16_t)0x0068
#define EEPROM_ALERT_MESSAGE1_BYTE13 (uint16_t)0x0069
#define EEPROM_ALERT_MESSAGE1_BYTE14 (uint16_t)0x006A
#define EEPROM_ALERT_MESSAGE1_BYTE15 (uint16_t)0x006B
#define EEPROM_ALERT_MESSAGE1_BYTE16 (uint16_t)0x006C
#define EEPROM_ALERT_MESSAGE1_BYTE17 (uint16_t)0x006D
#define EEPROM_ALERT_MESSAGE1_BYTE18 (uint16_t)0x006E
#define EEPROM_ALERT_MESSAGE1_BYTE19 (uint16_t)0x006F
#define EEPROM_ALERT_MESSAGE1_BYTE20 (uint16_t)0x0070
#define EEPROM_ALERT_MESSAGE1_BYTE21 (uint16_t)0x0071
#define EEPROM_ALERT_MESSAGE1_BYTE22 (uint16_t)0x0072
#define EEPROM_ALERT_MESSAGE1_BYTE23 (uint16_t)0x0073
#define EEPROM_ALERT_MESSAGE1_BYTE24 (uint16_t)0x0074
#define EEPROM_ALERT_MESSAGE1_BYTE25 (uint16_t)0x0075
#define EEPROM_ALERT_MESSAGE1_BYTE26 (uint16_t)0x0076
#define EEPROM_ALERT_MESSAGE1_BYTE27 (uint16_t)0x0077
#define EEPROM_ALERT_MESSAGE1_BYTE28 (uint16_t)0x0078
#define EEPROM_ALERT_MESSAGE1_BYTE29 (uint16_t)0x0079
#define EEPROM_ALERT_MESSAGE1_BYTE30 (uint16_t)0x007A
#define EEPROM_ALERT_MESSAGE1_BYTE31 (uint16_t)0x007B
#define EEPROM_ALERT_MESSAGE1_BYTE32 (uint16_t)0x007C
#define EEPROM_ALERT_MESSAGE1_BYTE33 (uint16_t)0x007D
#define EEPROM_ALERT_MESSAGE1_BYTE34 (uint16_t)0x007E
#define EEPROM_ALERT_MESSAGE1_BYTE35 (uint16_t)0x007F
#define EEPROM_ALERT_MESSAGE1_BYTE36 (uint16_t)0x0080
#define EEPROM_ALERT_MESSAGE1_BYTE37 (uint16_t)0x0081
#define EEPROM_ALERT_MESSAGE1_BYTE38 (uint16_t)0x0082
#define EEPROM_ALERT_MESSAGE1_BYTE39 (uint16_t)0x0083
#define EEPROM_ALERT_MESSAGE1_BYTE40 (uint16_t)0x0084
#define EEPROM_ALERT_MESSAGE1_BYTE41 (uint16_t)0x0085
#define EEPROM_ALERT_MESSAGE1_BYTE42 (uint16_t)0x0086
#define EEPROM_ALERT_MESSAGE1_BYTE43 (uint16_t)0x0087
#define EEPROM_ALERT_MESSAGE1_BYTE44 (uint16_t)0x0088
#define EEPROM_ALERT_MESSAGE1_BYTE45 (uint16_t)0x0089
#define EEPROM_ALERT_MESSAGE1_BYTE46 (uint16_t)0x008A
#define EEPROM_ALERT_MESSAGE1_BYTE47 (uint16_t)0x008B
#define EEPROM_ALERT_MESSAGE1_BYTE48 (uint16_t)0x008C
#define EEPROM_ALERT_MESSAGE1_BYTE49 (uint16_t)0x008D
#define EEPROM_ALERT_MESSAGE1_BYTE50 (uint16_t)0x008E
#define EEPROM_ALERT_MESSAGE1_BYTE51 (uint16_t)0x008F
#define EEPROM_ALERT_MESSAGE1_BYTE52 (uint16_t)0x0090
#define EEPROM_ALERT_MESSAGE1_BYTE53 (uint16_t)0x0091
#define EEPROM_ALERT_MESSAGE1_BYTE54 (uint16_t)0x0092
#define EEPROM_ALERT_MESSAGE1_BYTE55 (uint16_t)0x0093
#define EEPROM_ALERT_MESSAGE1_BYTE56 (uint16_t)0x0094
#define EEPROM_ALERT_MESSAGE1_BYTE57 (uint16_t)0x0095
#define EEPROM_ALERT_MESSAGE1_BYTE58 (uint16_t)0x0096
#define EEPROM_ALERT_MESSAGE1_BYTE59 (uint16_t)0x0097
#define EEPROM_ALERT_MESSAGE1_BYTE60 (uint16_t)0x0098
#define EEPROM_ALERT_MESSAGE1_BYTE61 (uint16_t)0x0099
#define EEPROM_ALERT_MESSAGE1_BYTE62 (uint16_t)0x009A
#define EEPROM_ALERT_MESSAGE1_BYTE63 (uint16_t)0x009B
#define EEPROM_ALERT_MESSAGE1_BYTE64 (uint16_t)0x009C
#define EEPROM_ALERT_MESSAGE2_BYTE1 (uint16_t)0x009D
#define EEPROM_ALERT_MESSAGE2_BYTE2 (uint16_t)0x009E
#define EEPROM_ALERT_MESSAGE2_BYTE3 (uint16_t)0x009F
#define EEPROM_ALERT_MESSAGE2_BYTE4 (uint16_t)0x00A0
#define EEPROM_ALERT_MESSAGE2_BYTE5 (uint16_t)0x00A1
#define EEPROM_ALERT_MESSAGE2_BYTE6 (uint16_t)0x00A2
#define EEPROM_ALERT_MESSAGE2_BYTE7 (uint16_t)0x00A3
#define EEPROM_ALERT_MESSAGE2_BYTE8 (uint16_t)0x00A4
#define EEPROM_ALERT_MESSAGE2_BYTE9 (uint16_t)0x00A5
#define EEPROM_ALERT_MESSAGE2_BYTE10 (uint16_t)0x00A6
#define EEPROM_ALERT_MESSAGE2_BYTE11 (uint16_t)0x00A7
#define EEPROM_ALERT_MESSAGE2_BYTE12 (uint16_t)0x00A8
#define EEPROM_ALERT_MESSAGE2_BYTE13 (uint16_t)0x00A9
#define EEPROM_ALERT_MESSAGE2_BYTE14 (uint16_t)0x00AA
#define EEPROM_ALERT_MESSAGE2_BYTE15 (uint16_t)0x00AB
#define EEPROM_ALERT_MESSAGE2_BYTE16 (uint16_t)0x00AC
#define EEPROM_ALERT_MESSAGE2_BYTE17 (uint16_t)0x00AD
#define EEPROM_ALERT_MESSAGE2_BYTE18 (uint16_t)0x00AE
#define EEPROM_ALERT_MESSAGE2_BYTE19 (uint16_t)0x00AF
#define EEPROM_ALERT_MESSAGE2_BYTE20 (uint16_t)0x00B0
#define EEPROM_ALERT_MESSAGE2_BYTE21 (uint16_t)0x00B1
#define EEPROM_ALERT_MESSAGE2_BYTE22 (uint16_t)0x00B2
#define EEPROM_ALERT_MESSAGE2_BYTE23 (uint16_t)0x00B3
#define EEPROM_ALERT_MESSAGE2_BYTE24 (uint16_t)0x00B4
#define EEPROM_ALERT_MESSAGE2_BYTE25 (uint16_t)0x00B5
#define EEPROM_ALERT_MESSAGE2_BYTE26 (uint16_t)0x00B6
#define EEPROM_ALERT_MESSAGE2_BYTE27 (uint16_t)0x00B7
#define EEPROM_ALERT_MESSAGE2_BYTE28 (uint16_t)0x00B8
#define EEPROM_ALERT_MESSAGE2_BYTE29 (uint16_t)0x00B9
#define EEPROM_ALERT_MESSAGE2_BYTE30 (uint16_t)0x00BA
#define EEPROM_ALERT_MESSAGE2_BYTE31 (uint16_t)0x00BB
#define EEPROM_ALERT_MESSAGE2_BYTE32 (uint16_t)0x00BC
#define EEPROM_ALERT_MESSAGE2_BYTE33 (uint16_t)0x00BD
#define EEPROM_ALERT_MESSAGE2_BYTE34 (uint16_t)0x00BE
#define EEPROM_ALERT_MESSAGE2_BYTE35 (uint16_t)0x00BF
#define EEPROM_ALERT_MESSAGE2_BYTE36 (uint16_t)0x00C0
#define EEPROM_ALERT_MESSAGE2_BYTE37 (uint16_t)0x00C1
#define EEPROM_ALERT_MESSAGE2_BYTE38 (uint16_t)0x00C2
#define EEPROM_ALERT_MESSAGE2_BYTE39 (uint16_t)0x00C3
#define EEPROM_ALERT_MESSAGE2_BYTE40 (uint16_t)0x00C4
#define EEPROM_ALERT_MESSAGE2_BYTE41 (uint16_t)0x00C5
#define EEPROM_ALERT_MESSAGE2_BYTE42 (uint16_t)0x00C6
#define EEPROM_ALERT_MESSAGE2_BYTE43 (uint16_t)0x00C7
#define EEPROM_ALERT_MESSAGE2_BYTE44 (uint16_t)0x00C8
#define EEPROM_ALERT_MESSAGE2_BYTE45 (uint16_t)0x00C9
#define EEPROM_ALERT_MESSAGE2_BYTE46 (uint16_t)0x00CA
#define EEPROM_ALERT_MESSAGE2_BYTE47 (uint16_t)0x00CB
#define EEPROM_ALERT_MESSAGE2_BYTE48 (uint16_t)0x00CC
#define EEPROM_ALERT_MESSAGE2_BYTE49 (uint16_t)0x00CD
#define EEPROM_ALERT_MESSAGE2_BYTE50 (uint16_t)0x00CE
#define EEPROM_ALERT_MESSAGE2_BYTE51 (uint16_t)0x00CF
#define EEPROM_ALERT_MESSAGE2_BYTE52 (uint16_t)0x00D0
#define EEPROM_ALERT_MESSAGE2_BYTE53 (uint16_t)0x00D1
#define EEPROM_ALERT_MESSAGE2_BYTE54 (uint16_t)0x00D2
#define EEPROM_ALERT_MESSAGE2_BYTE55 (uint16_t)0x00D3
#define EEPROM_ALERT_MESSAGE2_BYTE56 (uint16_t)0x00D4
#define EEPROM_ALERT_MESSAGE2_BYTE57 (uint16_t)0x00D5
#define EEPROM_ALERT_MESSAGE2_BYTE58 (uint16_t)0x00D6
#define EEPROM_ALERT_MESSAGE2_BYTE59 (uint16_t)0x00D7
#define EEPROM_ALERT_MESSAGE2_BYTE60 (uint16_t)0x00D8
#define EEPROM_ALERT_MESSAGE2_BYTE61 (uint16_t)0x00D9
#define EEPROM_ALERT_MESSAGE2_BYTE62 (uint16_t)0x00DA
#define EEPROM_ALERT_MESSAGE2_BYTE63 (uint16_t)0x00DB
#define EEPROM_ALERT_MESSAGE2_BYTE64 (uint16_t)0x00DC
#define EEPROM_ALERT_MESSAGE3_BYTE1 (uint16_t)0x00DD
#define EEPROM_ALERT_MESSAGE3_BYTE2 (uint16_t)0x00DE
#define EEPROM_ALERT_MESSAGE3_BYTE3 (uint16_t)0x00DF
#define EEPROM_ALERT_MESSAGE3_BYTE4 (uint16_t)0x00E0
#define EEPROM_ALERT_MESSAGE3_BYTE5 (uint16_t)0x00E1
#define EEPROM_ALERT_MESSAGE3_BYTE6 (uint16_t)0x00E2
#define EEPROM_ALERT_MESSAGE3_BYTE7 (uint16_t)0x00E3
#define EEPROM_ALERT_MESSAGE3_BYTE8 (uint16_t)0x00E4
#define EEPROM_ALERT_MESSAGE3_BYTE9 (uint16_t)0x00E5
#define EEPROM_ALERT_MESSAGE3_BYTE10 (uint16_t)0x00E6
#define EEPROM_ALERT_MESSAGE3_BYTE11 (uint16_t)0x00E7
#define EEPROM_ALERT_MESSAGE3_BYTE12 (uint16_t)0x00E8
#define EEPROM_ALERT_MESSAGE3_BYTE13 (uint16_t)0x00E9
#define EEPROM_ALERT_MESSAGE3_BYTE14 (uint16_t)0x00EA
#define EEPROM_ALERT_MESSAGE3_BYTE15 (uint16_t)0x00EB
#define EEPROM_ALERT_MESSAGE3_BYTE16 (uint16_t)0x00EC
#define EEPROM_ALERT_MESSAGE3_BYTE17 (uint16_t)0x00ED
#define EEPROM_ALERT_MESSAGE3_BYTE18 (uint16_t)0x00EE
#define EEPROM_ALERT_MESSAGE3_BYTE19 (uint16_t)0x00EF
#define EEPROM_ALERT_MESSAGE3_BYTE20 (uint16_t)0x00F0
#define EEPROM_ALERT_MESSAGE3_BYTE21 (uint16_t)0x00F1
#define EEPROM_ALERT_MESSAGE3_BYTE22 (uint16_t)0x00F2
#define EEPROM_ALERT_MESSAGE3_BYTE23 (uint16_t)0x00F3
#define EEPROM_ALERT_MESSAGE3_BYTE24 (uint16_t)0x00F4
#define EEPROM_ALERT_MESSAGE3_BYTE25 (uint16_t)0x00F5
#define EEPROM_ALERT_MESSAGE3_BYTE26 (uint16_t)0x00F6
#define EEPROM_ALERT_MESSAGE3_BYTE27 (uint16_t)0x00F7
#define EEPROM_ALERT_MESSAGE3_BYTE28 (uint16_t)0x00F8
#define EEPROM_ALERT_MESSAGE3_BYTE29 (uint16_t)0x00F9
#define EEPROM_ALERT_MESSAGE3_BYTE30 (uint16_t)0x00FA
#define EEPROM_ALERT_MESSAGE3_BYTE31 (uint16_t)0x00FB
#define EEPROM_ALERT_MESSAGE3_BYTE32 (uint16_t)0x00FC
#define EEPROM_ALERT_MESSAGE3_BYTE33 (uint16_t)0x00FD
#define EEPROM_ALERT_MESSAGE3_BYTE34 (uint16_t)0x00FE
#define EEPROM_ALERT_MESSAGE3_BYTE35 (uint16_t)0x00FF
#define EEPROM_ALERT_MESSAGE3_BYTE36 (uint16_t)0x0100
#define EEPROM_ALERT_MESSAGE3_BYTE37 (uint16_t)0x0101
#define EEPROM_ALERT_MESSAGE3_BYTE38 (uint16_t)0x0102
#define EEPROM_ALERT_MESSAGE3_BYTE39 (uint16_t)0x0103
#define EEPROM_ALERT_MESSAGE3_BYTE40 (uint16_t)0x0104
#define EEPROM_ALERT_MESSAGE3_BYTE41 (uint16_t)0x0105
#define EEPROM_ALERT_MESSAGE3_BYTE42 (uint16_t)0x0106
#define EEPROM_ALERT_MESSAGE3_BYTE43 (uint16_t)0x0107
#define EEPROM_ALERT_MESSAGE3_BYTE44 (uint16_t)0x0108
#define EEPROM_ALERT_MESSAGE3_BYTE45 (uint16_t)0x0109
#define EEPROM_ALERT_MESSAGE3_BYTE46 (uint16_t)0x010A
#define EEPROM_ALERT_MESSAGE3_BYTE47 (uint16_t)0x010B
#define EEPROM_ALERT_MESSAGE3_BYTE48 (uint16_t)0x010C
#define EEPROM_ALERT_MESSAGE3_BYTE49 (uint16_t)0x010D
#define EEPROM_ALERT_MESSAGE3_BYTE50 (uint16_t)0x010E
#define EEPROM_ALERT_MESSAGE3_BYTE51 (uint16_t)0x010F
#define EEPROM_ALERT_MESSAGE3_BYTE52 (uint16_t)0x0110
#define EEPROM_ALERT_MESSAGE3_BYTE53 (uint16_t)0x0111
#define EEPROM_ALERT_MESSAGE3_BYTE54 (uint16_t)0x0112
#define EEPROM_ALERT_MESSAGE3_BYTE55 (uint16_t)0x0113
#define EEPROM_ALERT_MESSAGE3_BYTE56 (uint16_t)0x0114
#define EEPROM_ALERT_MESSAGE3_BYTE57 (uint16_t)0x0115
#define EEPROM_ALERT_MESSAGE3_BYTE58 (uint16_t)0x0116
#define EEPROM_ALERT_MESSAGE3_BYTE59 (uint16_t)0x0117
#define EEPROM_ALERT_MESSAGE3_BYTE60 (uint16_t)0x0118
#define EEPROM_ALERT_MESSAGE3_BYTE61 (uint16_t)0x0119
#define EEPROM_ALERT_MESSAGE3_BYTE62 (uint16_t)0x011A
#define EEPROM_ALERT_MESSAGE3_BYTE63 (uint16_t)0x011B
#define EEPROM_ALERT_MESSAGE3_BYTE64 (uint16_t)0x011C
#define EEPROM_ALERT_MESSAGE4_BYTE1 (uint16_t)0x011D
#define EEPROM_ALERT_MESSAGE4_BYTE2 (uint16_t)0x011E
#define EEPROM_ALERT_MESSAGE4_BYTE3 (uint16_t)0x011F
#define EEPROM_ALERT_MESSAGE4_BYTE4 (uint16_t)0x0120
#define EEPROM_ALERT_MESSAGE4_BYTE5 (uint16_t)0x0121
#define EEPROM_ALERT_MESSAGE4_BYTE6 (uint16_t)0x0122
#define EEPROM_ALERT_MESSAGE4_BYTE7 (uint16_t)0x0123
#define EEPROM_ALERT_MESSAGE4_BYTE8 (uint16_t)0x0124
#define EEPROM_ALERT_MESSAGE4_BYTE9 (uint16_t)0x0125
#define EEPROM_ALERT_MESSAGE4_BYTE10 (uint16_t)0x0126
#define EEPROM_ALERT_MESSAGE4_BYTE11 (uint16_t)0x0127
#define EEPROM_ALERT_MESSAGE4_BYTE12 (uint16_t)0x0128
#define EEPROM_ALERT_MESSAGE4_BYTE13 (uint16_t)0x0129
#define EEPROM_ALERT_MESSAGE4_BYTE14 (uint16_t)0x012A
#define EEPROM_ALERT_MESSAGE4_BYTE15 (uint16_t)0x012B
#define EEPROM_ALERT_MESSAGE4_BYTE16 (uint16_t)0x012C
#define EEPROM_ALERT_MESSAGE4_BYTE17 (uint16_t)0x012D
#define EEPROM_ALERT_MESSAGE4_BYTE18 (uint16_t)0x012E
#define EEPROM_ALERT_MESSAGE4_BYTE19 (uint16_t)0x012F
#define EEPROM_ALERT_MESSAGE4_BYTE20 (uint16_t)0x0130
#define EEPROM_ALERT_MESSAGE4_BYTE21 (uint16_t)0x0131
#define EEPROM_ALERT_MESSAGE4_BYTE22 (uint16_t)0x0132
#define EEPROM_ALERT_MESSAGE4_BYTE23 (uint16_t)0x0133
#define EEPROM_ALERT_MESSAGE4_BYTE24 (uint16_t)0x0134
#define EEPROM_ALERT_MESSAGE4_BYTE25 (uint16_t)0x0135
#define EEPROM_ALERT_MESSAGE4_BYTE26 (uint16_t)0x0136
#define EEPROM_ALERT_MESSAGE4_BYTE27 (uint16_t)0x0137
#define EEPROM_ALERT_MESSAGE4_BYTE28 (uint16_t)0x0138
#define EEPROM_ALERT_MESSAGE4_BYTE29 (uint16_t)0x0139
#define EEPROM_ALERT_MESSAGE4_BYTE30 (uint16_t)0x013A
#define EEPROM_ALERT_MESSAGE4_BYTE31 (uint16_t)0x013B
#define EEPROM_ALERT_MESSAGE4_BYTE32 (uint16_t)0x013C
#define EEPROM_ALERT_MESSAGE4_BYTE33 (uint16_t)0x013D
#define EEPROM_ALERT_MESSAGE4_BYTE34 (uint16_t)0x013E
#define EEPROM_ALERT_MESSAGE4_BYTE35 (uint16_t)0x013F
#define EEPROM_ALERT_MESSAGE4_BYTE36 (uint16_t)0x0140
#define EEPROM_ALERT_MESSAGE4_BYTE37 (uint16_t)0x0141
#define EEPROM_ALERT_MESSAGE4_BYTE38 (uint16_t)0x0142
#define EEPROM_ALERT_MESSAGE4_BYTE39 (uint16_t)0x0143
#define EEPROM_ALERT_MESSAGE4_BYTE40 (uint16_t)0x0144
#define EEPROM_ALERT_MESSAGE4_BYTE41 (uint16_t)0x0145
#define EEPROM_ALERT_MESSAGE4_BYTE42 (uint16_t)0x0146
#define EEPROM_ALERT_MESSAGE4_BYTE43 (uint16_t)0x0147
#define EEPROM_ALERT_MESSAGE4_BYTE44 (uint16_t)0x0148
#define EEPROM_ALERT_MESSAGE4_BYTE45 (uint16_t)0x0149
#define EEPROM_ALERT_MESSAGE4_BYTE46 (uint16_t)0x014A
#define EEPROM_ALERT_MESSAGE4_BYTE47 (uint16_t)0x014B
#define EEPROM_ALERT_MESSAGE4_BYTE48 (uint16_t)0x014C
#define EEPROM_ALERT_MESSAGE4_BYTE49 (uint16_t)0x014D
#define EEPROM_ALERT_MESSAGE4_BYTE50 (uint16_t)0x014E
#define EEPROM_ALERT_MESSAGE4_BYTE51 (uint16_t)0x014F
#define EEPROM_ALERT_MESSAGE4_BYTE52 (uint16_t)0x0150
#define EEPROM_ALERT_MESSAGE4_BYTE53 (uint16_t)0x0151
#define EEPROM_ALERT_MESSAGE4_BYTE54 (uint16_t)0x0152
#define EEPROM_ALERT_MESSAGE4_BYTE55 (uint16_t)0x0153
#define EEPROM_ALERT_MESSAGE4_BYTE56 (uint16_t)0x0154
#define EEPROM_ALERT_MESSAGE4_BYTE57 (uint16_t)0x0155
#define EEPROM_ALERT_MESSAGE4_BYTE58 (uint16_t)0x0156
#define EEPROM_ALERT_MESSAGE4_BYTE59 (uint16_t)0x0157
#define EEPROM_ALERT_MESSAGE4_BYTE60 (uint16_t)0x0158
#define EEPROM_ALERT_MESSAGE4_BYTE61 (uint16_t)0x0159
#define EEPROM_ALERT_MESSAGE4_BYTE62 (uint16_t)0x015A
#define EEPROM_ALERT_MESSAGE4_BYTE63 (uint16_t)0x015B
#define EEPROM_ALERT_MESSAGE4_BYTE64 (uint16_t)0x015C
#define EEPROM_ALERT_MESSAGE5_BYTE1 (uint16_t)0x015D
#define EEPROM_ALERT_MESSAGE5_BYTE2 (uint16_t)0x015E
#define EEPROM_ALERT_MESSAGE5_BYTE3 (uint16_t)0x015F
#define EEPROM_ALERT_MESSAGE5_BYTE4 (uint16_t)0x0160
#define EEPROM_ALERT_MESSAGE5_BYTE5 (uint16_t)0x0161
#define EEPROM_ALERT_MESSAGE5_BYTE6 (uint16_t)0x0162
#define EEPROM_ALERT_MESSAGE5_BYTE7 (uint16_t)0x0163
#define EEPROM_ALERT_MESSAGE5_BYTE8 (uint16_t)0x0164
#define EEPROM_ALERT_MESSAGE5_BYTE9 (uint16_t)0x0165
#define EEPROM_ALERT_MESSAGE5_BYTE10 (uint16_t)0x0166
#define EEPROM_ALERT_MESSAGE5_BYTE11 (uint16_t)0x0167
#define EEPROM_ALERT_MESSAGE5_BYTE12 (uint16_t)0x0168
#define EEPROM_ALERT_MESSAGE5_BYTE13 (uint16_t)0x0169
#define EEPROM_ALERT_MESSAGE5_BYTE14 (uint16_t)0x016A
#define EEPROM_ALERT_MESSAGE5_BYTE15 (uint16_t)0x016B
#define EEPROM_ALERT_MESSAGE5_BYTE16 (uint16_t)0x016C
#define EEPROM_ALERT_MESSAGE5_BYTE17 (uint16_t)0x016D
#define EEPROM_ALERT_MESSAGE5_BYTE18 (uint16_t)0x016E
#define EEPROM_ALERT_MESSAGE5_BYTE19 (uint16_t)0x016F
#define EEPROM_ALERT_MESSAGE5_BYTE20 (uint16_t)0x0170
#define EEPROM_ALERT_MESSAGE5_BYTE21 (uint16_t)0x0171
#define EEPROM_ALERT_MESSAGE5_BYTE22 (uint16_t)0x0172
#define EEPROM_ALERT_MESSAGE5_BYTE23 (uint16_t)0x0173
#define EEPROM_ALERT_MESSAGE5_BYTE24 (uint16_t)0x0174
#define EEPROM_ALERT_MESSAGE5_BYTE25 (uint16_t)0x0175
#define EEPROM_ALERT_MESSAGE5_BYTE26 (uint16_t)0x0176
#define EEPROM_ALERT_MESSAGE5_BYTE27 (uint16_t)0x0177
#define EEPROM_ALERT_MESSAGE5_BYTE28 (uint16_t)0x0178
#define EEPROM_ALERT_MESSAGE5_BYTE29 (uint16_t)0x0179
#define EEPROM_ALERT_MESSAGE5_BYTE30 (uint16_t)0x017A
#define EEPROM_ALERT_MESSAGE5_BYTE31 (uint16_t)0x017B
#define EEPROM_ALERT_MESSAGE5_BYTE32 (uint16_t)0x017C
#define EEPROM_ALERT_MESSAGE5_BYTE33 (uint16_t)0x017D
#define EEPROM_ALERT_MESSAGE5_BYTE34 (uint16_t)0x017E
#define EEPROM_ALERT_MESSAGE5_BYTE35 (uint16_t)0x017F
#define EEPROM_ALERT_MESSAGE5_BYTE36 (uint16_t)0x0180
#define EEPROM_ALERT_MESSAGE5_BYTE37 (uint16_t)0x0181
#define EEPROM_ALERT_MESSAGE5_BYTE38 (uint16_t)0x0182
#define EEPROM_ALERT_MESSAGE5_BYTE39 (uint16_t)0x0183
#define EEPROM_ALERT_MESSAGE5_BYTE40 (uint16_t)0x0184
#define EEPROM_ALERT_MESSAGE5_BYTE41 (uint16_t)0x0185
#define EEPROM_ALERT_MESSAGE5_BYTE42 (uint16_t)0x0186
#define EEPROM_ALERT_MESSAGE5_BYTE43 (uint16_t)0x0187
#define EEPROM_ALERT_MESSAGE5_BYTE44 (uint16_t)0x0188
#define EEPROM_ALERT_MESSAGE5_BYTE45 (uint16_t)0x0189
#define EEPROM_ALERT_MESSAGE5_BYTE46 (uint16_t)0x018A
#define EEPROM_ALERT_MESSAGE5_BYTE47 (uint16_t)0x018B
#define EEPROM_ALERT_MESSAGE5_BYTE48 (uint16_t)0x018C
#define EEPROM_ALERT_MESSAGE5_BYTE49 (uint16_t)0x018D
#define EEPROM_ALERT_MESSAGE5_BYTE50 (uint16_t)0x018E
#define EEPROM_ALERT_MESSAGE5_BYTE51 (uint16_t)0x018F
#define EEPROM_ALERT_MESSAGE5_BYTE52 (uint16_t)0x0190
#define EEPROM_ALERT_MESSAGE5_BYTE53 (uint16_t)0x0191
#define EEPROM_ALERT_MESSAGE5_BYTE54 (uint16_t)0x0192
#define EEPROM_ALERT_MESSAGE5_BYTE55 (uint16_t)0x0193
#define EEPROM_ALERT_MESSAGE5_BYTE56 (uint16_t)0x0194
#define EEPROM_ALERT_MESSAGE5_BYTE57 (uint16_t)0x0195
#define EEPROM_ALERT_MESSAGE5_BYTE58 (uint16_t)0x0196
#define EEPROM_ALERT_MESSAGE5_BYTE59 (uint16_t)0x0197
#define EEPROM_ALERT_MESSAGE5_BYTE60 (uint16_t)0x0198
#define EEPROM_ALERT_MESSAGE5_BYTE61 (uint16_t)0x0199
#define EEPROM_ALERT_MESSAGE5_BYTE62 (uint16_t)0x019A
#define EEPROM_ALERT_MESSAGE5_BYTE63 (uint16_t)0x019B
#define EEPROM_ALERT_MESSAGE5_BYTE64 (uint16_t)0x019C
static const uint16_t map_alert_message_byte1[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE1,
    EEPROM_ALERT_MESSAGE2_BYTE1,
    EEPROM_ALERT_MESSAGE3_BYTE1,
    EEPROM_ALERT_MESSAGE4_BYTE1,
    EEPROM_ALERT_MESSAGE5_BYTE1
    };

static const uint16_t map_alert_message_byte2[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE2,
    EEPROM_ALERT_MESSAGE2_BYTE2,
    EEPROM_ALERT_MESSAGE3_BYTE2,
    EEPROM_ALERT_MESSAGE4_BYTE2,
    EEPROM_ALERT_MESSAGE5_BYTE2
    };

static const uint16_t map_alert_message_byte3[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE3,
    EEPROM_ALERT_MESSAGE2_BYTE3,
    EEPROM_ALERT_MESSAGE3_BYTE3,
    EEPROM_ALERT_MESSAGE4_BYTE3,
    EEPROM_ALERT_MESSAGE5_BYTE3
    };

static const uint16_t map_alert_message_byte4[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE4,
    EEPROM_ALERT_MESSAGE2_BYTE4,
    EEPROM_ALERT_MESSAGE3_BYTE4,
    EEPROM_ALERT_MESSAGE4_BYTE4,
    EEPROM_ALERT_MESSAGE5_BYTE4
    };

static const uint16_t map_alert_message_byte5[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE5,
    EEPROM_ALERT_MESSAGE2_BYTE5,
    EEPROM_ALERT_MESSAGE3_BYTE5,
    EEPROM_ALERT_MESSAGE4_BYTE5,
    EEPROM_ALERT_MESSAGE5_BYTE5
    };

static const uint16_t map_alert_message_byte6[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE6,
    EEPROM_ALERT_MESSAGE2_BYTE6,
    EEPROM_ALERT_MESSAGE3_BYTE6,
    EEPROM_ALERT_MESSAGE4_BYTE6,
    EEPROM_ALERT_MESSAGE5_BYTE6
    };

static const uint16_t map_alert_message_byte7[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE7,
    EEPROM_ALERT_MESSAGE2_BYTE7,
    EEPROM_ALERT_MESSAGE3_BYTE7,
    EEPROM_ALERT_MESSAGE4_BYTE7,
    EEPROM_ALERT_MESSAGE5_BYTE7
    };

static const uint16_t map_alert_message_byte8[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE8,
    EEPROM_ALERT_MESSAGE2_BYTE8,
    EEPROM_ALERT_MESSAGE3_BYTE8,
    EEPROM_ALERT_MESSAGE4_BYTE8,
    EEPROM_ALERT_MESSAGE5_BYTE8
    };

static const uint16_t map_alert_message_byte9[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE9,
    EEPROM_ALERT_MESSAGE2_BYTE9,
    EEPROM_ALERT_MESSAGE3_BYTE9,
    EEPROM_ALERT_MESSAGE4_BYTE9,
    EEPROM_ALERT_MESSAGE5_BYTE9
    };

static const uint16_t map_alert_message_byte10[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE10,
    EEPROM_ALERT_MESSAGE2_BYTE10,
    EEPROM_ALERT_MESSAGE3_BYTE10,
    EEPROM_ALERT_MESSAGE4_BYTE10,
    EEPROM_ALERT_MESSAGE5_BYTE10
    };

static const uint16_t map_alert_message_byte11[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE11,
    EEPROM_ALERT_MESSAGE2_BYTE11,
    EEPROM_ALERT_MESSAGE3_BYTE11,
    EEPROM_ALERT_MESSAGE4_BYTE11,
    EEPROM_ALERT_MESSAGE5_BYTE11
    };

static const uint16_t map_alert_message_byte12[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE12,
    EEPROM_ALERT_MESSAGE2_BYTE12,
    EEPROM_ALERT_MESSAGE3_BYTE12,
    EEPROM_ALERT_MESSAGE4_BYTE12,
    EEPROM_ALERT_MESSAGE5_BYTE12
    };

static const uint16_t map_alert_message_byte13[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE13,
    EEPROM_ALERT_MESSAGE2_BYTE13,
    EEPROM_ALERT_MESSAGE3_BYTE13,
    EEPROM_ALERT_MESSAGE4_BYTE13,
    EEPROM_ALERT_MESSAGE5_BYTE13
    };

static const uint16_t map_alert_message_byte14[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE14,
    EEPROM_ALERT_MESSAGE2_BYTE14,
    EEPROM_ALERT_MESSAGE3_BYTE14,
    EEPROM_ALERT_MESSAGE4_BYTE14,
    EEPROM_ALERT_MESSAGE5_BYTE14
    };

static const uint16_t map_alert_message_byte15[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE15,
    EEPROM_ALERT_MESSAGE2_BYTE15,
    EEPROM_ALERT_MESSAGE3_BYTE15,
    EEPROM_ALERT_MESSAGE4_BYTE15,
    EEPROM_ALERT_MESSAGE5_BYTE15
    };

static const uint16_t map_alert_message_byte16[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE16,
    EEPROM_ALERT_MESSAGE2_BYTE16,
    EEPROM_ALERT_MESSAGE3_BYTE16,
    EEPROM_ALERT_MESSAGE4_BYTE16,
    EEPROM_ALERT_MESSAGE5_BYTE16
    };

static const uint16_t map_alert_message_byte17[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE17,
    EEPROM_ALERT_MESSAGE2_BYTE17,
    EEPROM_ALERT_MESSAGE3_BYTE17,
    EEPROM_ALERT_MESSAGE4_BYTE17,
    EEPROM_ALERT_MESSAGE5_BYTE17
    };

static const uint16_t map_alert_message_byte18[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE18,
    EEPROM_ALERT_MESSAGE2_BYTE18,
    EEPROM_ALERT_MESSAGE3_BYTE18,
    EEPROM_ALERT_MESSAGE4_BYTE18,
    EEPROM_ALERT_MESSAGE5_BYTE18
    };

static const uint16_t map_alert_message_byte19[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE19,
    EEPROM_ALERT_MESSAGE2_BYTE19,
    EEPROM_ALERT_MESSAGE3_BYTE19,
    EEPROM_ALERT_MESSAGE4_BYTE19,
    EEPROM_ALERT_MESSAGE5_BYTE19
    };

static const uint16_t map_alert_message_byte20[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE20,
    EEPROM_ALERT_MESSAGE2_BYTE20,
    EEPROM_ALERT_MESSAGE3_BYTE20,
    EEPROM_ALERT_MESSAGE4_BYTE20,
    EEPROM_ALERT_MESSAGE5_BYTE20
    };

static const uint16_t map_alert_message_byte21[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE21,
    EEPROM_ALERT_MESSAGE2_BYTE21,
    EEPROM_ALERT_MESSAGE3_BYTE21,
    EEPROM_ALERT_MESSAGE4_BYTE21,
    EEPROM_ALERT_MESSAGE5_BYTE21
    };

static const uint16_t map_alert_message_byte22[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE22,
    EEPROM_ALERT_MESSAGE2_BYTE22,
    EEPROM_ALERT_MESSAGE3_BYTE22,
    EEPROM_ALERT_MESSAGE4_BYTE22,
    EEPROM_ALERT_MESSAGE5_BYTE22
    };

static const uint16_t map_alert_message_byte23[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE23,
    EEPROM_ALERT_MESSAGE2_BYTE23,
    EEPROM_ALERT_MESSAGE3_BYTE23,
    EEPROM_ALERT_MESSAGE4_BYTE23,
    EEPROM_ALERT_MESSAGE5_BYTE23
    };

static const uint16_t map_alert_message_byte24[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE24,
    EEPROM_ALERT_MESSAGE2_BYTE24,
    EEPROM_ALERT_MESSAGE3_BYTE24,
    EEPROM_ALERT_MESSAGE4_BYTE24,
    EEPROM_ALERT_MESSAGE5_BYTE24
    };

static const uint16_t map_alert_message_byte25[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE25,
    EEPROM_ALERT_MESSAGE2_BYTE25,
    EEPROM_ALERT_MESSAGE3_BYTE25,
    EEPROM_ALERT_MESSAGE4_BYTE25,
    EEPROM_ALERT_MESSAGE5_BYTE25
    };

static const uint16_t map_alert_message_byte26[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE26,
    EEPROM_ALERT_MESSAGE2_BYTE26,
    EEPROM_ALERT_MESSAGE3_BYTE26,
    EEPROM_ALERT_MESSAGE4_BYTE26,
    EEPROM_ALERT_MESSAGE5_BYTE26
    };

static const uint16_t map_alert_message_byte27[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE27,
    EEPROM_ALERT_MESSAGE2_BYTE27,
    EEPROM_ALERT_MESSAGE3_BYTE27,
    EEPROM_ALERT_MESSAGE4_BYTE27,
    EEPROM_ALERT_MESSAGE5_BYTE27
    };

static const uint16_t map_alert_message_byte28[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE28,
    EEPROM_ALERT_MESSAGE2_BYTE28,
    EEPROM_ALERT_MESSAGE3_BYTE28,
    EEPROM_ALERT_MESSAGE4_BYTE28,
    EEPROM_ALERT_MESSAGE5_BYTE28
    };

static const uint16_t map_alert_message_byte29[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE29,
    EEPROM_ALERT_MESSAGE2_BYTE29,
    EEPROM_ALERT_MESSAGE3_BYTE29,
    EEPROM_ALERT_MESSAGE4_BYTE29,
    EEPROM_ALERT_MESSAGE5_BYTE29
    };

static const uint16_t map_alert_message_byte30[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE30,
    EEPROM_ALERT_MESSAGE2_BYTE30,
    EEPROM_ALERT_MESSAGE3_BYTE30,
    EEPROM_ALERT_MESSAGE4_BYTE30,
    EEPROM_ALERT_MESSAGE5_BYTE30
    };

static const uint16_t map_alert_message_byte31[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE31,
    EEPROM_ALERT_MESSAGE2_BYTE31,
    EEPROM_ALERT_MESSAGE3_BYTE31,
    EEPROM_ALERT_MESSAGE4_BYTE31,
    EEPROM_ALERT_MESSAGE5_BYTE31
    };

static const uint16_t map_alert_message_byte32[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE32,
    EEPROM_ALERT_MESSAGE2_BYTE32,
    EEPROM_ALERT_MESSAGE3_BYTE32,
    EEPROM_ALERT_MESSAGE4_BYTE32,
    EEPROM_ALERT_MESSAGE5_BYTE32
    };

static const uint16_t map_alert_message_byte33[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE33,
    EEPROM_ALERT_MESSAGE2_BYTE33,
    EEPROM_ALERT_MESSAGE3_BYTE33,
    EEPROM_ALERT_MESSAGE4_BYTE33,
    EEPROM_ALERT_MESSAGE5_BYTE33
    };

static const uint16_t map_alert_message_byte34[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE34,
    EEPROM_ALERT_MESSAGE2_BYTE34,
    EEPROM_ALERT_MESSAGE3_BYTE34,
    EEPROM_ALERT_MESSAGE4_BYTE34,
    EEPROM_ALERT_MESSAGE5_BYTE34
    };

static const uint16_t map_alert_message_byte35[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE35,
    EEPROM_ALERT_MESSAGE2_BYTE35,
    EEPROM_ALERT_MESSAGE3_BYTE35,
    EEPROM_ALERT_MESSAGE4_BYTE35,
    EEPROM_ALERT_MESSAGE5_BYTE35
    };

static const uint16_t map_alert_message_byte36[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE36,
    EEPROM_ALERT_MESSAGE2_BYTE36,
    EEPROM_ALERT_MESSAGE3_BYTE36,
    EEPROM_ALERT_MESSAGE4_BYTE36,
    EEPROM_ALERT_MESSAGE5_BYTE36
    };

static const uint16_t map_alert_message_byte37[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE37,
    EEPROM_ALERT_MESSAGE2_BYTE37,
    EEPROM_ALERT_MESSAGE3_BYTE37,
    EEPROM_ALERT_MESSAGE4_BYTE37,
    EEPROM_ALERT_MESSAGE5_BYTE37
    };

static const uint16_t map_alert_message_byte38[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE38,
    EEPROM_ALERT_MESSAGE2_BYTE38,
    EEPROM_ALERT_MESSAGE3_BYTE38,
    EEPROM_ALERT_MESSAGE4_BYTE38,
    EEPROM_ALERT_MESSAGE5_BYTE38
    };

static const uint16_t map_alert_message_byte39[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE39,
    EEPROM_ALERT_MESSAGE2_BYTE39,
    EEPROM_ALERT_MESSAGE3_BYTE39,
    EEPROM_ALERT_MESSAGE4_BYTE39,
    EEPROM_ALERT_MESSAGE5_BYTE39
    };

static const uint16_t map_alert_message_byte40[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE40,
    EEPROM_ALERT_MESSAGE2_BYTE40,
    EEPROM_ALERT_MESSAGE3_BYTE40,
    EEPROM_ALERT_MESSAGE4_BYTE40,
    EEPROM_ALERT_MESSAGE5_BYTE40
    };

static const uint16_t map_alert_message_byte41[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE41,
    EEPROM_ALERT_MESSAGE2_BYTE41,
    EEPROM_ALERT_MESSAGE3_BYTE41,
    EEPROM_ALERT_MESSAGE4_BYTE41,
    EEPROM_ALERT_MESSAGE5_BYTE41
    };

static const uint16_t map_alert_message_byte42[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE42,
    EEPROM_ALERT_MESSAGE2_BYTE42,
    EEPROM_ALERT_MESSAGE3_BYTE42,
    EEPROM_ALERT_MESSAGE4_BYTE42,
    EEPROM_ALERT_MESSAGE5_BYTE42
    };

static const uint16_t map_alert_message_byte43[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE43,
    EEPROM_ALERT_MESSAGE2_BYTE43,
    EEPROM_ALERT_MESSAGE3_BYTE43,
    EEPROM_ALERT_MESSAGE4_BYTE43,
    EEPROM_ALERT_MESSAGE5_BYTE43
    };

static const uint16_t map_alert_message_byte44[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE44,
    EEPROM_ALERT_MESSAGE2_BYTE44,
    EEPROM_ALERT_MESSAGE3_BYTE44,
    EEPROM_ALERT_MESSAGE4_BYTE44,
    EEPROM_ALERT_MESSAGE5_BYTE44
    };

static const uint16_t map_alert_message_byte45[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE45,
    EEPROM_ALERT_MESSAGE2_BYTE45,
    EEPROM_ALERT_MESSAGE3_BYTE45,
    EEPROM_ALERT_MESSAGE4_BYTE45,
    EEPROM_ALERT_MESSAGE5_BYTE45
    };

static const uint16_t map_alert_message_byte46[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE46,
    EEPROM_ALERT_MESSAGE2_BYTE46,
    EEPROM_ALERT_MESSAGE3_BYTE46,
    EEPROM_ALERT_MESSAGE4_BYTE46,
    EEPROM_ALERT_MESSAGE5_BYTE46
    };

static const uint16_t map_alert_message_byte47[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE47,
    EEPROM_ALERT_MESSAGE2_BYTE47,
    EEPROM_ALERT_MESSAGE3_BYTE47,
    EEPROM_ALERT_MESSAGE4_BYTE47,
    EEPROM_ALERT_MESSAGE5_BYTE47
    };

static const uint16_t map_alert_message_byte48[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE48,
    EEPROM_ALERT_MESSAGE2_BYTE48,
    EEPROM_ALERT_MESSAGE3_BYTE48,
    EEPROM_ALERT_MESSAGE4_BYTE48,
    EEPROM_ALERT_MESSAGE5_BYTE48
    };

static const uint16_t map_alert_message_byte49[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE49,
    EEPROM_ALERT_MESSAGE2_BYTE49,
    EEPROM_ALERT_MESSAGE3_BYTE49,
    EEPROM_ALERT_MESSAGE4_BYTE49,
    EEPROM_ALERT_MESSAGE5_BYTE49
    };

static const uint16_t map_alert_message_byte50[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE50,
    EEPROM_ALERT_MESSAGE2_BYTE50,
    EEPROM_ALERT_MESSAGE3_BYTE50,
    EEPROM_ALERT_MESSAGE4_BYTE50,
    EEPROM_ALERT_MESSAGE5_BYTE50
    };

static const uint16_t map_alert_message_byte51[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE51,
    EEPROM_ALERT_MESSAGE2_BYTE51,
    EEPROM_ALERT_MESSAGE3_BYTE51,
    EEPROM_ALERT_MESSAGE4_BYTE51,
    EEPROM_ALERT_MESSAGE5_BYTE51
    };

static const uint16_t map_alert_message_byte52[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE52,
    EEPROM_ALERT_MESSAGE2_BYTE52,
    EEPROM_ALERT_MESSAGE3_BYTE52,
    EEPROM_ALERT_MESSAGE4_BYTE52,
    EEPROM_ALERT_MESSAGE5_BYTE52
    };

static const uint16_t map_alert_message_byte53[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE53,
    EEPROM_ALERT_MESSAGE2_BYTE53,
    EEPROM_ALERT_MESSAGE3_BYTE53,
    EEPROM_ALERT_MESSAGE4_BYTE53,
    EEPROM_ALERT_MESSAGE5_BYTE53
    };

static const uint16_t map_alert_message_byte54[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE54,
    EEPROM_ALERT_MESSAGE2_BYTE54,
    EEPROM_ALERT_MESSAGE3_BYTE54,
    EEPROM_ALERT_MESSAGE4_BYTE54,
    EEPROM_ALERT_MESSAGE5_BYTE54
    };

static const uint16_t map_alert_message_byte55[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE55,
    EEPROM_ALERT_MESSAGE2_BYTE55,
    EEPROM_ALERT_MESSAGE3_BYTE55,
    EEPROM_ALERT_MESSAGE4_BYTE55,
    EEPROM_ALERT_MESSAGE5_BYTE55
    };

static const uint16_t map_alert_message_byte56[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE56,
    EEPROM_ALERT_MESSAGE2_BYTE56,
    EEPROM_ALERT_MESSAGE3_BYTE56,
    EEPROM_ALERT_MESSAGE4_BYTE56,
    EEPROM_ALERT_MESSAGE5_BYTE56
    };

static const uint16_t map_alert_message_byte57[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE57,
    EEPROM_ALERT_MESSAGE2_BYTE57,
    EEPROM_ALERT_MESSAGE3_BYTE57,
    EEPROM_ALERT_MESSAGE4_BYTE57,
    EEPROM_ALERT_MESSAGE5_BYTE57
    };

static const uint16_t map_alert_message_byte58[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE58,
    EEPROM_ALERT_MESSAGE2_BYTE58,
    EEPROM_ALERT_MESSAGE3_BYTE58,
    EEPROM_ALERT_MESSAGE4_BYTE58,
    EEPROM_ALERT_MESSAGE5_BYTE58
    };

static const uint16_t map_alert_message_byte59[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE59,
    EEPROM_ALERT_MESSAGE2_BYTE59,
    EEPROM_ALERT_MESSAGE3_BYTE59,
    EEPROM_ALERT_MESSAGE4_BYTE59,
    EEPROM_ALERT_MESSAGE5_BYTE59
    };

static const uint16_t map_alert_message_byte60[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE60,
    EEPROM_ALERT_MESSAGE2_BYTE60,
    EEPROM_ALERT_MESSAGE3_BYTE60,
    EEPROM_ALERT_MESSAGE4_BYTE60,
    EEPROM_ALERT_MESSAGE5_BYTE60
    };

static const uint16_t map_alert_message_byte61[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE61,
    EEPROM_ALERT_MESSAGE2_BYTE61,
    EEPROM_ALERT_MESSAGE3_BYTE61,
    EEPROM_ALERT_MESSAGE4_BYTE61,
    EEPROM_ALERT_MESSAGE5_BYTE61
    };

static const uint16_t map_alert_message_byte62[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE62,
    EEPROM_ALERT_MESSAGE2_BYTE62,
    EEPROM_ALERT_MESSAGE3_BYTE62,
    EEPROM_ALERT_MESSAGE4_BYTE62,
    EEPROM_ALERT_MESSAGE5_BYTE62
    };

static const uint16_t map_alert_message_byte63[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE63,
    EEPROM_ALERT_MESSAGE2_BYTE63,
    EEPROM_ALERT_MESSAGE3_BYTE63,
    EEPROM_ALERT_MESSAGE4_BYTE63,
    EEPROM_ALERT_MESSAGE5_BYTE63
    };

static const uint16_t map_alert_message_byte64[MAX_ALERTS] = {
    EEPROM_ALERT_MESSAGE1_BYTE64,
    EEPROM_ALERT_MESSAGE2_BYTE64,
    EEPROM_ALERT_MESSAGE3_BYTE64,
    EEPROM_ALERT_MESSAGE4_BYTE64,
    EEPROM_ALERT_MESSAGE5_BYTE64
    };

// EEPROM Memory Map - alert compare
#define EEPROM_ALERT_COMPARE1_BYTE1 (uint16_t)0x019D
#define EEPROM_ALERT_COMPARE2_BYTE1 (uint16_t)0x019E
#define EEPROM_ALERT_COMPARE3_BYTE1 (uint16_t)0x019F
#define EEPROM_ALERT_COMPARE4_BYTE1 (uint16_t)0x01A0
#define EEPROM_ALERT_COMPARE5_BYTE1 (uint16_t)0x01A1
static const uint16_t map_alert_compare_byte1[MAX_ALERTS] = {
    EEPROM_ALERT_COMPARE1_BYTE1,
    EEPROM_ALERT_COMPARE2_BYTE1,
    EEPROM_ALERT_COMPARE3_BYTE1,
    EEPROM_ALERT_COMPARE4_BYTE1,
    EEPROM_ALERT_COMPARE5_BYTE1
    };

// EEPROM Memory Map - alert threshold
#define EEPROM_ALERT_THRESHOLD1_BYTE1 (uint16_t)0x01A2
#define EEPROM_ALERT_THRESHOLD1_BYTE2 (uint16_t)0x01A3
#define EEPROM_ALERT_THRESHOLD1_BYTE3 (uint16_t)0x01A4
#define EEPROM_ALERT_THRESHOLD1_BYTE4 (uint16_t)0x01A5
#define EEPROM_ALERT_THRESHOLD2_BYTE1 (uint16_t)0x01A6
#define EEPROM_ALERT_THRESHOLD2_BYTE2 (uint16_t)0x01A7
#define EEPROM_ALERT_THRESHOLD2_BYTE3 (uint16_t)0x01A8
#define EEPROM_ALERT_THRESHOLD2_BYTE4 (uint16_t)0x01A9
static const uint16_t map_alert_threshold_byte1[MAX_DYNAMICS] = {
    EEPROM_ALERT_THRESHOLD1_BYTE1,
    EEPROM_ALERT_THRESHOLD2_BYTE1
    };

static const uint16_t map_alert_threshold_byte2[MAX_DYNAMICS] = {
    EEPROM_ALERT_THRESHOLD1_BYTE2,
    EEPROM_ALERT_THRESHOLD2_BYTE2
    };

static const uint16_t map_alert_threshold_byte3[MAX_DYNAMICS] = {
    EEPROM_ALERT_THRESHOLD1_BYTE3,
    EEPROM_ALERT_THRESHOLD2_BYTE3
    };

static const uint16_t map_alert_threshold_byte4[MAX_DYNAMICS] = {
    EEPROM_ALERT_THRESHOLD1_BYTE4,
    EEPROM_ALERT_THRESHOLD2_BYTE4
    };

// EEPROM Memory Map - dynamic enable
#define EEPROM_DYNAMIC_ENABLE1_BYTE1 (uint16_t)0x01AA
#define EEPROM_DYNAMIC_ENABLE2_BYTE1 (uint16_t)0x01AB
static const uint16_t map_dynamic_enable_byte1[MAX_DYNAMICS] = {
    EEPROM_DYNAMIC_ENABLE1_BYTE1,
    EEPROM_DYNAMIC_ENABLE2_BYTE1
    };

// EEPROM Memory Map - dynamic priority
#define EEPROM_DYNAMIC_PRIORITY1_BYTE1 (uint16_t)0x01AC
#define EEPROM_DYNAMIC_PRIORITY2_BYTE1 (uint16_t)0x01AD
static const uint16_t map_dynamic_priority_byte1[MAX_DYNAMICS] = {
    EEPROM_DYNAMIC_PRIORITY1_BYTE1,
    EEPROM_DYNAMIC_PRIORITY2_BYTE1
    };

// EEPROM Memory Map - dynamic compare
#define EEPROM_DYNAMIC_COMPARE1_BYTE1 (uint16_t)0x01AE
#define EEPROM_DYNAMIC_COMPARE2_BYTE1 (uint16_t)0x01AF
#define EEPROM_DYNAMIC_COMPARE3_BYTE1 (uint16_t)0x01B0
#define EEPROM_DYNAMIC_COMPARE4_BYTE1 (uint16_t)0x01B1
#define EEPROM_DYNAMIC_COMPARE5_BYTE1 (uint16_t)0x01B2
static const uint16_t map_dynamic_compare_byte1[MAX_ALERTS] = {
    EEPROM_DYNAMIC_COMPARE1_BYTE1,
    EEPROM_DYNAMIC_COMPARE2_BYTE1,
    EEPROM_DYNAMIC_COMPARE3_BYTE1,
    EEPROM_DYNAMIC_COMPARE4_BYTE1,
    EEPROM_DYNAMIC_COMPARE5_BYTE1
    };

// EEPROM Memory Map - dynamic Threshold
#define EEPROM_DYNAMIC_THRESHOLD1_BYTE1 (uint16_t)0x01B3
#define EEPROM_DYNAMIC_THRESHOLD1_BYTE2 (uint16_t)0x01B4
#define EEPROM_DYNAMIC_THRESHOLD1_BYTE3 (uint16_t)0x01B5
#define EEPROM_DYNAMIC_THRESHOLD1_BYTE4 (uint16_t)0x01B6
#define EEPROM_DYNAMIC_THRESHOLD2_BYTE1 (uint16_t)0x01B7
#define EEPROM_DYNAMIC_THRESHOLD2_BYTE2 (uint16_t)0x01B8
#define EEPROM_DYNAMIC_THRESHOLD2_BYTE3 (uint16_t)0x01B9
#define EEPROM_DYNAMIC_THRESHOLD2_BYTE4 (uint16_t)0x01BA
static const uint16_t map_dynamic_threshold_byte1[MAX_DYNAMICS] = {
    EEPROM_DYNAMIC_THRESHOLD1_BYTE1,
    EEPROM_DYNAMIC_THRESHOLD2_BYTE1
    };

static const uint16_t map_dynamic_threshold_byte2[MAX_DYNAMICS] = {
    EEPROM_DYNAMIC_THRESHOLD1_BYTE2,
    EEPROM_DYNAMIC_THRESHOLD2_BYTE2
    };

static const uint16_t map_dynamic_threshold_byte3[MAX_DYNAMICS] = {
    EEPROM_DYNAMIC_THRESHOLD1_BYTE3,
    EEPROM_DYNAMIC_THRESHOLD2_BYTE3
    };

static const uint16_t map_dynamic_threshold_byte4[MAX_DYNAMICS] = {
    EEPROM_DYNAMIC_THRESHOLD1_BYTE4,
    EEPROM_DYNAMIC_THRESHOLD2_BYTE4
    };

// EEPROM Memory Map - dynamic Index
#define EEPROM_DYNAMIC_INDEX1_BYTE1 (uint16_t)0x01BB
#define EEPROM_DYNAMIC_INDEX2_BYTE1 (uint16_t)0x01BC
static const uint16_t map_dynamic_index_byte1[MAX_DYNAMICS] = {
    EEPROM_DYNAMIC_INDEX1_BYTE1,
    EEPROM_DYNAMIC_INDEX2_BYTE1
    };

// EEPROM Memory Map - dynamic pid
#define EEPROM_DYNAMIC_PID1_BYTE1 (uint16_t)0x01BD
#define EEPROM_DYNAMIC_PID1_BYTE2 (uint16_t)0x01BE
#define EEPROM_DYNAMIC_PID1_BYTE3 (uint16_t)0x01BF
#define EEPROM_DYNAMIC_PID1_BYTE4 (uint16_t)0x01C0
#define EEPROM_DYNAMIC_PID2_BYTE1 (uint16_t)0x01C1
#define EEPROM_DYNAMIC_PID2_BYTE2 (uint16_t)0x01C2
#define EEPROM_DYNAMIC_PID2_BYTE3 (uint16_t)0x01C3
#define EEPROM_DYNAMIC_PID2_BYTE4 (uint16_t)0x01C4
static const uint16_t map_dynamic_pid_byte1[MAX_DYNAMICS] = {
    EEPROM_DYNAMIC_PID1_BYTE1,
    EEPROM_DYNAMIC_PID2_BYTE1
    };

static const uint16_t map_dynamic_pid_byte2[MAX_DYNAMICS] = {
    EEPROM_DYNAMIC_PID1_BYTE2,
    EEPROM_DYNAMIC_PID2_BYTE2
    };

static const uint16_t map_dynamic_pid_byte3[MAX_DYNAMICS] = {
    EEPROM_DYNAMIC_PID1_BYTE3,
    EEPROM_DYNAMIC_PID2_BYTE3
    };

static const uint16_t map_dynamic_pid_byte4[MAX_DYNAMICS] = {
    EEPROM_DYNAMIC_PID1_BYTE4,
    EEPROM_DYNAMIC_PID2_BYTE4
    };

// EEPROM Memory Map - dynamic units
#define EEPROM_DYNAMIC_UNITS1_BYTE1 (uint16_t)0x01C5
#define EEPROM_DYNAMIC_UNITS2_BYTE1 (uint16_t)0x01C6
static const uint16_t map_dynamic_units_byte1[MAX_DYNAMICS] = {
    EEPROM_DYNAMIC_UNITS1_BYTE1,
    EEPROM_DYNAMIC_UNITS2_BYTE1
    };


static VIEW_STATE settings_view_enable[MAX_VIEWS] = {DEFAULT_VIEW_ENABLE};
static uint8_t settings_view_num_gauges[MAX_GAUGES_PER_VIEW] = {DEFAULT_VIEW_NUM_GAUGES};
static VIEW_BACKGROUND settings_view_background[MAX_VIEWS] = {DEFAULT_VIEW_BACKGROUND};
static GAUGE_THEME settings_view_gauge_theme[MAX_VIEWS][MAX_GAUGES_PER_VIEW] = {DEFAULT_VIEW_GAUGE_THEME};
static uint32_t settings_view_gauge_pid[MAX_VIEWS][MAX_GAUGES_PER_VIEW] = {DEFAULT_VIEW_GAUGE_PID};
static PID_UNITS settings_view_gauge_units[MAX_VIEWS][MAX_GAUGES_PER_VIEW] = {DEFAULT_VIEW_GAUGE_UNITS};
static ALERT_STATE settings_alert_enable[MAX_ALERTS] = {DEFAULT_ALERT_ENABLE};
static uint32_t settings_alert_pid[MAX_ALERTS] = {DEFAULT_ALERT_PID};
static PID_UNITS settings_alert_units[MAX_ALERTS] = {DEFAULT_ALERT_UNITS};
static char settings_alert_message[MAX_ALERTS][ALERT_MESSAGE_LEN] = {DEFAULT_ALERT_MESSAGE};
static ALERT_COMPARISON settings_alert_compare[MAX_ALERTS] = {DEFAULT_ALERT_COMPARE};
static float settings_alert_threshold[MAX_DYNAMICS] = {DEFAULT_ALERT_THRESHOLD};
static DYNAMIC_STATE settings_dynamic_enable[MAX_DYNAMICS] = {DEFAULT_DYNAMIC_ENABLE};
static DYNAMIC_PRIORITY settings_dynamic_priority[MAX_DYNAMICS] = {DEFAULT_DYNAMIC_PRIORITY};
static DYNAMIC_COMPARISON settings_dynamic_compare[MAX_ALERTS] = {DEFAULT_DYNAMIC_COMPARE};
static float settings_dynamic_threshold[MAX_DYNAMICS] = {DEFAULT_DYNAMIC_THRESHOLD};
static uint8_t settings_dynamic_index[MAX_DYNAMICS] = {DEFAULT_DYNAMIC_INDEX};
static uint32_t settings_dynamic_pid[MAX_DYNAMICS] = {DEFAULT_DYNAMIC_PID};
static PID_UNITS settings_dynamic_units[MAX_DYNAMICS] = {DEFAULT_DYNAMIC_UNITS};


static void load_view_enable(uint8_t idx, VIEW_STATE *view_enable_val);
static void load_view_num_gauges(uint8_t idx, uint8_t *view_num_gauges_val);
static void load_view_background(uint8_t idx, VIEW_BACKGROUND *view_background_val);
static void load_view_gauge_theme(uint8_t idx_view, uint8_t idx_gauge, GAUGE_THEME *view_gauge_theme_val);
static void load_view_gauge_pid(uint8_t idx_view, uint8_t idx_gauge, uint32_t *view_gauge_pid_val);
static void load_view_gauge_units(uint8_t idx_view, uint8_t idx_gauge, PID_UNITS *view_gauge_units_val);
static void load_alert_enable(uint8_t idx, ALERT_STATE *alert_enable_val);
static void load_alert_pid(uint8_t idx, uint32_t *alert_pid_val);
static void load_alert_units(uint8_t idx, PID_UNITS *alert_units_val);
static void load_alert_message(uint8_t idx, char *alert_message_val);
static void load_alert_compare(uint8_t idx, ALERT_COMPARISON *alert_compare_val);
static void load_alert_threshold(uint8_t idx, float *alert_threshold_val);
static void load_dynamic_enable(uint8_t idx, DYNAMIC_STATE *dynamic_enable_val);
static void load_dynamic_priority(uint8_t idx, DYNAMIC_PRIORITY *dynamic_priority_val);
static void load_dynamic_compare(uint8_t idx, DYNAMIC_COMPARISON *dynamic_compare_val);
static void load_dynamic_threshold(uint8_t idx, float *dynamic_threshold_val);
static void load_dynamic_index(uint8_t idx, uint8_t *dynamic_index_val);
static void load_dynamic_pid(uint8_t idx, uint32_t *dynamic_pid_val);
static void load_dynamic_units(uint8_t idx, PID_UNITS *dynamic_units_val);

bool config_to_json(char *buffer, size_t buffer_size) {
    cJSON *root = cJSON_CreateObject();

    if (!root) return false;

    // Serialize view
    cJSON *views = cJSON_AddArrayToObject(root, "view");
    for(int i = 0; i < MAX_VIEWS; i++) {
        cJSON *view = cJSON_CreateObject();
        cJSON_AddStringToObject(view, "enable", view_state_string[get_view_enable(i)]);
        cJSON_AddNumberToObject(view, "num_gauges", get_view_num_gauges(i));
        cJSON_AddStringToObject(view, "background", view_background_string[get_view_background(i)]);
        cJSON_AddItemToArray(views, view);
    }

    // Serialize alert
    cJSON *alerts = cJSON_AddArrayToObject(root, "alert");
    for(int i = 0; i < MAX_ALERTS; i++) {
        cJSON *alert = cJSON_CreateObject();
        cJSON_AddStringToObject(alert, "enable", alert_state_string[get_alert_enable(i)]);
        cJSON_AddNumberToObject(alert, "pid", get_alert_pid(i));
        cJSON_AddNumberToObject(alert, "units", get_alert_units(i));
        char tmp_alert_message[64] = {0};
        get_alert_message(i, tmp_alert_message);
        cJSON_AddStringToObject(alert, "message", tmp_alert_message);
        cJSON_AddStringToObject(alert, "compare", alert_comparison_string[get_alert_compare(i)]);
        cJSON_AddNumberToObject(alert, "threshold", get_alert_threshold(i));
        cJSON_AddItemToArray(alerts, alert);
    }

    // Serialize dynamic
    cJSON *dynamics = cJSON_AddArrayToObject(root, "dynamic");
    for(int i = 0; i < MAX_DYNAMICS; i++) {
        cJSON *dynamic = cJSON_CreateObject();
        cJSON_AddStringToObject(dynamic, "enable", dynamic_state_string[get_dynamic_enable(i)]);
        cJSON_AddStringToObject(dynamic, "priority", dynamic_priority_string[get_dynamic_priority(i)]);
        cJSON_AddStringToObject(dynamic, "compare", dynamic_comparison_string[get_dynamic_compare(i)]);
        cJSON_AddNumberToObject(dynamic, "Threshold", get_dynamic_threshold(i));
        cJSON_AddNumberToObject(dynamic, "Index", get_dynamic_index(i));
        cJSON_AddNumberToObject(dynamic, "pid", get_dynamic_pid(i));
        cJSON_AddNumberToObject(dynamic, "units", get_dynamic_units(i));
        cJSON_AddItemToArray(dynamics, dynamic);
    }

    // Print into user buffer
    bool success = cJSON_PrintPreallocated(root, buffer, buffer_size, /*format*/ 1);
    cJSON_Delete(root);
    return success;
}

static uint8_t cached_settings[455];

static settings_write *write;
static settings_read *read;

void settings_setWriteHandler(settings_write *writeHandler) { write = writeHandler; }
void settings_setReadHandler(settings_read *readHandler) { read = readHandler; }

// Converts an EEPROM address to a linear array index
static uint16_t eeprom_address_to_linear_index(uint16_t address) {
    uint16_t page = address >> 5;
    uint16_t offset = address & 0x1F; // Mask lower 5 bits (0-31)
    return (page * 32) + offset;

}

uint8_t read_eeprom(uint16_t bAdd)
{
	uint8_t byte = 0xFF;
	byte = read(bAdd); // Read from the EEPROM
	cached_settings[bAdd] = byte; // cache the data
	return byte;
}

void write_eeprom(uint16_t bAdd, uint8_t bData)
{
	write(bAdd, bData); // Write to the EEPROM
	cached_settings[bAdd] = bData; // cache the data
}

uint8_t get_eeprom_byte(uint16_t bAdd)
{
	return cached_settings[bAdd];
}

void load_settings(void)
{
    for( uint8_t idx = 0; idx < MAX_VIEWS; idx++ )
        load_view_enable(idx, &settings_view_enable[idx]);

    for( uint8_t idx = 0; idx < MAX_GAUGES_PER_VIEW; idx++ )
        load_view_num_gauges(idx, &settings_view_num_gauges[idx]);

    for( uint8_t idx = 0; idx < MAX_VIEWS; idx++ )
        load_view_background(idx, &settings_view_background[idx]);

    for( uint8_t idx_view = 0; idx_view < MAX_VIEWS; idx_view++ )
        for( uint8_t idx_gauge = 0; idx_gauge < MAX_GAUGES_PER_VIEW; idx_gauge++ )
            load_view_gauge_theme(idx_view, idx_gauge, &settings_view_gauge_theme[idx_view][idx_gauge]);

    for( uint8_t idx_view = 0; idx_view < MAX_VIEWS; idx_view++ )
        for( uint8_t idx_gauge = 0; idx_gauge < MAX_GAUGES_PER_VIEW; idx_gauge++ )
            load_view_gauge_pid(idx_view, idx_gauge, &settings_view_gauge_pid[idx_view][idx_gauge]);

    for( uint8_t idx_view = 0; idx_view < MAX_VIEWS; idx_view++ )
        for( uint8_t idx_gauge = 0; idx_gauge < MAX_GAUGES_PER_VIEW; idx_gauge++ )
            load_view_gauge_units(idx_view, idx_gauge, &settings_view_gauge_units[idx_view][idx_gauge]);

    for( uint8_t idx = 0; idx < MAX_ALERTS; idx++ )
        load_alert_enable(idx, &settings_alert_enable[idx]);

    for( uint8_t idx = 0; idx < MAX_ALERTS; idx++ )
        load_alert_pid(idx, &settings_alert_pid[idx]);

    for( uint8_t idx = 0; idx < MAX_ALERTS; idx++ )
        load_alert_units(idx, &settings_alert_units[idx]);

    for( uint8_t idx = 0; idx < MAX_ALERTS; idx++ )
        load_alert_message(idx, settings_alert_message[idx]);

    for( uint8_t idx = 0; idx < MAX_ALERTS; idx++ )
        load_alert_compare(idx, &settings_alert_compare[idx]);

    for( uint8_t idx = 0; idx < MAX_DYNAMICS; idx++ )
        load_alert_threshold(idx, &settings_alert_threshold[idx]);

    for( uint8_t idx = 0; idx < MAX_DYNAMICS; idx++ )
        load_dynamic_enable(idx, &settings_dynamic_enable[idx]);

    for( uint8_t idx = 0; idx < MAX_DYNAMICS; idx++ )
        load_dynamic_priority(idx, &settings_dynamic_priority[idx]);

    for( uint8_t idx = 0; idx < MAX_ALERTS; idx++ )
        load_dynamic_compare(idx, &settings_dynamic_compare[idx]);

    for( uint8_t idx = 0; idx < MAX_DYNAMICS; idx++ )
        load_dynamic_threshold(idx, &settings_dynamic_threshold[idx]);

    for( uint8_t idx = 0; idx < MAX_DYNAMICS; idx++ )
        load_dynamic_index(idx, &settings_dynamic_index[idx]);

    for( uint8_t idx = 0; idx < MAX_DYNAMICS; idx++ )
        load_dynamic_pid(idx, &settings_dynamic_pid[idx]);

    for( uint8_t idx = 0; idx < MAX_DYNAMICS; idx++ )
        load_dynamic_units(idx, &settings_dynamic_units[idx]);

}




/********************************************************************************
*                                  View enable                                  
*
* @param idx_view    index of the view
* @param enable    Enable or disable view by index
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
const char *view_state_string[] = {
    "Disabled",
    "Enabled"
};

static void load_view_enable(uint8_t idx, VIEW_STATE *view_enable_val)
{
    uint8_t bytes[EE_SIZE_VIEW_ENABLE];

    bytes[0] = read_eeprom(map_view_enable_byte1[idx]);

    memcpy(view_enable_val, bytes, EE_SIZE_VIEW_ENABLE);
}

static void save_view_enable(uint8_t idx, VIEW_STATE *view_enable)
{
    uint8_t bytes[EE_SIZE_VIEW_ENABLE];

    memcpy(bytes, view_enable, EE_SIZE_VIEW_ENABLE);

    write_eeprom(map_view_enable_byte1[idx], bytes[0]);
}

bool verify_view_enable(VIEW_STATE view_enable)
{
    if (view_enable >= VIEW_STATE_RESERVED)
        return 0;
    else
        return 1;
}

VIEW_STATE get_view_enable(uint8_t idx)
{
    // Verify the View enable value is valid
    if (!verify_view_enable(settings_view_enable[idx]))
        return DEFAULT_VIEW_ENABLE;

    return settings_view_enable[idx];
}

// Set the View enable
bool set_view_enable(uint8_t idx, VIEW_STATE view_enable, bool save)
{
    // Verify the View enable value is valid
    if (!verify_view_enable(view_enable))
        return false;

    // Check to see if the View enable EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        // Reload the current setting saved in EEPROM
        load_view_enable(idx, &settings_view_enable[idx]);

        if (settings_view_enable[idx] != view_enable)
        {
            save_view_enable(idx, &view_enable);
        }
    }

    settings_view_enable[idx] = view_enable;

    return 1;
}

VIEW_STATE get_view_enable_from_string(const char *str)
{
    if(strcmp(str, "Disabled") == 0) return VIEW_STATE_DISABLED;
    if(strcmp(str, "Enabled") == 0) return VIEW_STATE_ENABLED;
    return VIEW_STATE_RESERVED;
}



/********************************************************************************
*                                Number of gauges                               
*
* @param idx_view    index of the view
* @param num_gauges    Define the number of gauges for view by index
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static void load_view_num_gauges(uint8_t idx, uint8_t *view_num_gauges_val)
{
    uint8_t bytes[EE_SIZE_VIEW_NUM_GAUGES];

    bytes[0] = read_eeprom(map_view_num_gauges_byte1[idx]);

    memcpy(view_num_gauges_val, bytes, EE_SIZE_VIEW_NUM_GAUGES);
}

static void save_view_num_gauges(uint8_t idx, uint8_t *view_num_gauges)
{
    uint8_t bytes[EE_SIZE_VIEW_NUM_GAUGES];

    memcpy(bytes, view_num_gauges, EE_SIZE_VIEW_NUM_GAUGES);

    write_eeprom(map_view_num_gauges_byte1[idx], bytes[0]);
}

bool verify_view_num_gauges(uint8_t view_num_gauges)
{
    if (view_num_gauges > MAX_GAUGES_PER_VIEW)
        return 0;

    else
        return 1;
}

uint8_t get_view_num_gauges(uint8_t idx)
{
    // Verify the Number of gauges value is valid
    if (!verify_view_num_gauges(settings_view_num_gauges[idx]))
        return DEFAULT_VIEW_NUM_GAUGES;

    return settings_view_num_gauges[idx];
}

// Set the Number of gauges
bool set_view_num_gauges(uint8_t idx, uint8_t view_num_gauges, bool save)
{
    // Verify the Number of gauges value is valid
    if (!verify_view_num_gauges(view_num_gauges))
        return false;

    // Check to see if the Number of gauges EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        // Reload the current setting saved in EEPROM
        load_view_num_gauges(idx, &settings_view_num_gauges[idx]);

        if (settings_view_num_gauges[idx] != view_num_gauges)
        {
            save_view_num_gauges(idx, &view_num_gauges);
        }
    }

    settings_view_num_gauges[idx] = view_num_gauges;

    return 1;
}


/********************************************************************************
*                                   Background                                  
*
* @param idx_view    index of the view
* @param background    Set the background color or image of a view by index
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
const char *view_background_string[] = {
    "Black",
    "Flare",
    "User1"
};

static void load_view_background(uint8_t idx, VIEW_BACKGROUND *view_background_val)
{
    uint8_t bytes[EE_SIZE_VIEW_BACKGROUND];

    bytes[0] = read_eeprom(map_view_background_byte1[idx]);

    memcpy(view_background_val, bytes, EE_SIZE_VIEW_BACKGROUND);
}

static void save_view_background(uint8_t idx, VIEW_BACKGROUND *view_background)
{
    uint8_t bytes[EE_SIZE_VIEW_BACKGROUND];

    memcpy(bytes, view_background, EE_SIZE_VIEW_BACKGROUND);

    write_eeprom(map_view_background_byte1[idx], bytes[0]);
}

bool verify_view_background(VIEW_BACKGROUND view_background)
{
    if (view_background >= VIEW_BACKGROUND_RESERVED)
        return 0;
    else
        return 1;
}

VIEW_BACKGROUND get_view_background(uint8_t idx)
{
    // Verify the Background value is valid
    if (!verify_view_background(settings_view_background[idx]))
        return DEFAULT_VIEW_BACKGROUND;

    return settings_view_background[idx];
}

// Set the Background
bool set_view_background(uint8_t idx, VIEW_BACKGROUND view_background, bool save)
{
    // Verify the Background value is valid
    if (!verify_view_background(view_background))
        return false;

    // Check to see if the Background EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        // Reload the current setting saved in EEPROM
        load_view_background(idx, &settings_view_background[idx]);

        if (settings_view_background[idx] != view_background)
        {
            save_view_background(idx, &view_background);
        }
    }

    settings_view_background[idx] = view_background;

    return 1;
}

VIEW_BACKGROUND get_view_background_from_string(const char *str)
{
    if(strcmp(str, "Black") == 0) return VIEW_BACKGROUND_BLACK;
    if(strcmp(str, "Flare") == 0) return VIEW_BACKGROUND_FLARE;
    if(strcmp(str, "User1") == 0) return VIEW_BACKGROUND_USER1;
    return VIEW_BACKGROUND_RESERVED;
}



/********************************************************************************
*                          Theme assigned to the gauge                          
*
* @param idx_view    index of the view
* @param idx_gauge    index of the gauge
* @param theme    Set the gauge theme by view and gauge index
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
const char *gauge_theme_string[] = {
    "Stock ST",
    "Grumpy Cat",
    "Linear",
    "Radial"
};

static void load_view_gauge_theme(uint8_t idx_view, uint8_t idx_gauge, GAUGE_THEME *view_gauge_theme_val)
{
    uint8_t bytes[EE_SIZE_VIEW_GAUGE_THEME];

    bytes[0] = read_eeprom(map_view_gauge_theme_byte1[idx_view][idx_gauge]);

    memcpy(view_gauge_theme_val, bytes, EE_SIZE_VIEW_GAUGE_THEME);
}

static void save_view_gauge_theme(uint8_t idx_view, uint8_t idx_gauge, GAUGE_THEME *view_gauge_theme)
{
    uint8_t bytes[EE_SIZE_VIEW_GAUGE_THEME];

    memcpy(bytes, view_gauge_theme, EE_SIZE_VIEW_GAUGE_THEME);

    write_eeprom(map_view_gauge_theme_byte1[idx_view][idx_gauge], bytes[0]);
}

bool verify_view_gauge_theme(GAUGE_THEME view_gauge_theme)
{
    if (view_gauge_theme >= GAUGE_THEME_RESERVED)
        return 0;
    else
        return 1;
}

GAUGE_THEME get_view_gauge_theme(uint8_t idx_view, uint8_t idx_gauge)
{
    // Verify the Theme assigned to the gauge value is valid
    if (!verify_view_gauge_theme(settings_view_gauge_theme[idx_view][idx_gauge]))
        return DEFAULT_VIEW_GAUGE_THEME;

    return settings_view_gauge_theme[idx_view][idx_gauge];
}

// Set the Theme assigned to the gauge
bool set_view_gauge_theme(uint8_t idx_view, uint8_t idx_gauge, GAUGE_THEME view_gauge_theme, bool save)
{
    // Verify the Theme assigned to the gauge value is valid
    if (!verify_view_gauge_theme(view_gauge_theme))
        return false;

    // Check to see if the Theme assigned to the gauge EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        // Reload the current setting saved in EEPROM
        load_view_gauge_theme(idx_view, idx_gauge, &settings_view_gauge_theme[idx_view][idx_gauge]);

        if (settings_view_gauge_theme[idx_view][idx_gauge] != view_gauge_theme)
        {
            save_view_gauge_theme(idx_view, idx_gauge, &view_gauge_theme);
        }
    }

    settings_view_gauge_theme[idx_view][idx_gauge] = view_gauge_theme;

    return 1;
}

GAUGE_THEME get_view_gauge_theme_from_string(const char *str)
{
    if(strcmp(str, "Stock ST") == 0) return GAUGE_THEME_STOCK_ST;
    if(strcmp(str, "Grumpy Cat") == 0) return GAUGE_THEME_GRUMPY_CAT;
    if(strcmp(str, "Linear") == 0) return GAUGE_THEME_LINEAR;
    if(strcmp(str, "Radial") == 0) return GAUGE_THEME_RADIAL;
    return GAUGE_THEME_RESERVED;
}



/********************************************************************************
*                           PID assigned to the gauge                           
*
* @param idx_view    index of the view
* @param idx_gauge    index of the gauge
* @param pid    Set the gauge PID by view and gauge index
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static void load_view_gauge_pid(uint8_t idx_view, uint8_t idx_gauge, uint32_t *view_gauge_pid_val)
{
    uint8_t bytes[EE_SIZE_VIEW_GAUGE_PID];

    bytes[3] = read_eeprom(map_view_gauge_pid_byte1[idx_view][idx_gauge]);
    bytes[2] = read_eeprom(map_view_gauge_pid_byte2[idx_view][idx_gauge]);
    bytes[1] = read_eeprom(map_view_gauge_pid_byte3[idx_view][idx_gauge]);
    bytes[0] = read_eeprom(map_view_gauge_pid_byte4[idx_view][idx_gauge]);

    memcpy(view_gauge_pid_val, bytes, EE_SIZE_VIEW_GAUGE_PID);
}

static void save_view_gauge_pid(uint8_t idx_view, uint8_t idx_gauge, uint32_t *view_gauge_pid)
{
    uint8_t bytes[EE_SIZE_VIEW_GAUGE_PID];

    memcpy(bytes, view_gauge_pid, EE_SIZE_VIEW_GAUGE_PID);

    write_eeprom(map_view_gauge_pid_byte1[idx_view][idx_gauge], bytes[3]);
    write_eeprom(map_view_gauge_pid_byte2[idx_view][idx_gauge], bytes[2]);
    write_eeprom(map_view_gauge_pid_byte3[idx_view][idx_gauge], bytes[1]);
    write_eeprom(map_view_gauge_pid_byte4[idx_view][idx_gauge], bytes[0]);
}

bool verify_view_gauge_pid(uint32_t view_gauge_pid)
{
    if (view_gauge_pid < 1)
        return 0;

    if (view_gauge_pid > 16777215)
        return 0;

    else
        return 1;
}

uint32_t get_view_gauge_pid(uint8_t idx_view, uint8_t idx_gauge)
{
    // Verify the PID assigned to the gauge value is valid
    if (!verify_view_gauge_pid(settings_view_gauge_pid[idx_view][idx_gauge]))
        return DEFAULT_VIEW_GAUGE_PID;

    return settings_view_gauge_pid[idx_view][idx_gauge];
}

// Set the PID assigned to the gauge
bool set_view_gauge_pid(uint8_t idx_view, uint8_t idx_gauge, uint32_t view_gauge_pid, bool save)
{
    // Verify the PID assigned to the gauge value is valid
    if (!verify_view_gauge_pid(view_gauge_pid))
        return false;

    // Check to see if the PID assigned to the gauge EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        // Reload the current setting saved in EEPROM
        load_view_gauge_pid(idx_view, idx_gauge, &settings_view_gauge_pid[idx_view][idx_gauge]);

        if (settings_view_gauge_pid[idx_view][idx_gauge] != view_gauge_pid)
        {
            save_view_gauge_pid(idx_view, idx_gauge, &view_gauge_pid);
        }
    }

    settings_view_gauge_pid[idx_view][idx_gauge] = view_gauge_pid;

    return 1;
}


/********************************************************************************
*                        PID units assigned to the gauge                        
*
* @param idx_view    index of the view
* @param idx_gauge    index of the gauge
* @param units    Set the PID units by view and gauge index
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static void load_view_gauge_units(uint8_t idx_view, uint8_t idx_gauge, PID_UNITS *view_gauge_units_val)
{
    uint8_t bytes[EE_SIZE_VIEW_GAUGE_UNITS];

    bytes[0] = read_eeprom(map_view_gauge_units_byte1[idx_view][idx_gauge]);

    memcpy(view_gauge_units_val, bytes, EE_SIZE_VIEW_GAUGE_UNITS);
}

static void save_view_gauge_units(uint8_t idx_view, uint8_t idx_gauge, PID_UNITS *view_gauge_units)
{
    uint8_t bytes[EE_SIZE_VIEW_GAUGE_UNITS];

    memcpy(bytes, view_gauge_units, EE_SIZE_VIEW_GAUGE_UNITS);

    write_eeprom(map_view_gauge_units_byte1[idx_view][idx_gauge], bytes[0]);
}

bool verify_view_gauge_units(PID_UNITS view_gauge_units)
{
    if (view_gauge_units < 1)
        return 0;

    if (view_gauge_units > 255)
        return 0;

    else
        return 1;
}

PID_UNITS get_view_gauge_units(uint8_t idx_view, uint8_t idx_gauge)
{
    // Verify the PID units assigned to the gauge value is valid
    if (!verify_view_gauge_units(settings_view_gauge_units[idx_view][idx_gauge]))
        return DEFAULT_VIEW_GAUGE_UNITS;

    return settings_view_gauge_units[idx_view][idx_gauge];
}

// Set the PID units assigned to the gauge
bool set_view_gauge_units(uint8_t idx_view, uint8_t idx_gauge, PID_UNITS view_gauge_units, bool save)
{
    // Verify the PID units assigned to the gauge value is valid
    if (!verify_view_gauge_units(view_gauge_units))
        return false;

    // Check to see if the PID units assigned to the gauge EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        // Reload the current setting saved in EEPROM
        load_view_gauge_units(idx_view, idx_gauge, &settings_view_gauge_units[idx_view][idx_gauge]);

        if (settings_view_gauge_units[idx_view][idx_gauge] != view_gauge_units)
        {
            save_view_gauge_units(idx_view, idx_gauge, &view_gauge_units);
        }
    }

    settings_view_gauge_units[idx_view][idx_gauge] = view_gauge_units;

    return 1;
}


/********************************************************************************
*                                  Alert enable                                 
*
* @param idx_alert    index of the alert
* @param enable    Enable or disable view by index
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
const char *alert_state_string[] = {
    "Disabled",
    "Enabled"
};

static void load_alert_enable(uint8_t idx, ALERT_STATE *alert_enable_val)
{
    uint8_t bytes[EE_SIZE_ALERT_ENABLE];

    bytes[0] = read_eeprom(map_alert_enable_byte1[idx]);

    memcpy(alert_enable_val, bytes, EE_SIZE_ALERT_ENABLE);
}

static void save_alert_enable(uint8_t idx, ALERT_STATE *alert_enable)
{
    uint8_t bytes[EE_SIZE_ALERT_ENABLE];

    memcpy(bytes, alert_enable, EE_SIZE_ALERT_ENABLE);

    write_eeprom(map_alert_enable_byte1[idx], bytes[0]);
}

bool verify_alert_enable(ALERT_STATE alert_enable)
{
    if (alert_enable >= ALERT_STATE_RESERVED)
        return 0;
    else
        return 1;
}

ALERT_STATE get_alert_enable(uint8_t idx)
{
    // Verify the Alert enable value is valid
    if (!verify_alert_enable(settings_alert_enable[idx]))
        return DEFAULT_ALERT_ENABLE;

    return settings_alert_enable[idx];
}

// Set the Alert enable
bool set_alert_enable(uint8_t idx, ALERT_STATE alert_enable, bool save)
{
    // Verify the Alert enable value is valid
    if (!verify_alert_enable(alert_enable))
        return false;

    // Check to see if the Alert enable EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        // Reload the current setting saved in EEPROM
        load_alert_enable(idx, &settings_alert_enable[idx]);

        if (settings_alert_enable[idx] != alert_enable)
        {
            save_alert_enable(idx, &alert_enable);
        }
    }

    settings_alert_enable[idx] = alert_enable;

    return 1;
}

ALERT_STATE get_alert_enable_from_string(const char *str)
{
    if(strcmp(str, "Disabled") == 0) return ALERT_STATE_DISABLED;
    if(strcmp(str, "Enabled") == 0) return ALERT_STATE_ENABLED;
    return ALERT_STATE_RESERVED;
}



/********************************************************************************
*                           PID assigned to the alert                           
*
* @param idx_alert    index of the alert
* @param pid    Set the PID by alert index
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static void load_alert_pid(uint8_t idx, uint32_t *alert_pid_val)
{
    uint8_t bytes[EE_SIZE_ALERT_PID];

    bytes[3] = read_eeprom(map_alert_pid_byte1[idx]);
    bytes[2] = read_eeprom(map_alert_pid_byte2[idx]);
    bytes[1] = read_eeprom(map_alert_pid_byte3[idx]);
    bytes[0] = read_eeprom(map_alert_pid_byte4[idx]);

    memcpy(alert_pid_val, bytes, EE_SIZE_ALERT_PID);
}

static void save_alert_pid(uint8_t idx, uint32_t *alert_pid)
{
    uint8_t bytes[EE_SIZE_ALERT_PID];

    memcpy(bytes, alert_pid, EE_SIZE_ALERT_PID);

    write_eeprom(map_alert_pid_byte1[idx], bytes[3]);
    write_eeprom(map_alert_pid_byte2[idx], bytes[2]);
    write_eeprom(map_alert_pid_byte3[idx], bytes[1]);
    write_eeprom(map_alert_pid_byte4[idx], bytes[0]);
}

bool verify_alert_pid(uint32_t alert_pid)
{
    if (alert_pid < 1)
        return 0;

    if (alert_pid > 16777215)
        return 0;

    else
        return 1;
}

uint32_t get_alert_pid(uint8_t idx)
{
    // Verify the PID assigned to the alert value is valid
    if (!verify_alert_pid(settings_alert_pid[idx]))
        return DEFAULT_ALERT_PID;

    return settings_alert_pid[idx];
}

// Set the PID assigned to the alert
bool set_alert_pid(uint8_t idx, uint32_t alert_pid, bool save)
{
    // Verify the PID assigned to the alert value is valid
    if (!verify_alert_pid(alert_pid))
        return false;

    // Check to see if the PID assigned to the alert EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        // Reload the current setting saved in EEPROM
        load_alert_pid(idx, &settings_alert_pid[idx]);

        if (settings_alert_pid[idx] != alert_pid)
        {
            save_alert_pid(idx, &alert_pid);
        }
    }

    settings_alert_pid[idx] = alert_pid;

    return 1;
}


/********************************************************************************
*                        PID units assigned to the alert                        
*
* @param idx_alert    index of the alert
* @param units    Set the PID units by alert index
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static void load_alert_units(uint8_t idx, PID_UNITS *alert_units_val)
{
    uint8_t bytes[EE_SIZE_ALERT_UNITS];

    bytes[0] = read_eeprom(map_alert_units_byte1[idx]);

    memcpy(alert_units_val, bytes, EE_SIZE_ALERT_UNITS);
}

static void save_alert_units(uint8_t idx, PID_UNITS *alert_units)
{
    uint8_t bytes[EE_SIZE_ALERT_UNITS];

    memcpy(bytes, alert_units, EE_SIZE_ALERT_UNITS);

    write_eeprom(map_alert_units_byte1[idx], bytes[0]);
}

bool verify_alert_units(PID_UNITS alert_units)
{
    if (alert_units < 1)
        return 0;

    if (alert_units > 255)
        return 0;

    else
        return 1;
}

PID_UNITS get_alert_units(uint8_t idx)
{
    // Verify the PID units assigned to the alert value is valid
    if (!verify_alert_units(settings_alert_units[idx]))
        return DEFAULT_ALERT_UNITS;

    return settings_alert_units[idx];
}

// Set the PID units assigned to the alert
bool set_alert_units(uint8_t idx, PID_UNITS alert_units, bool save)
{
    // Verify the PID units assigned to the alert value is valid
    if (!verify_alert_units(alert_units))
        return false;

    // Check to see if the PID units assigned to the alert EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        // Reload the current setting saved in EEPROM
        load_alert_units(idx, &settings_alert_units[idx]);

        if (settings_alert_units[idx] != alert_units)
        {
            save_alert_units(idx, &alert_units);
        }
    }

    settings_alert_units[idx] = alert_units;

    return 1;
}


/********************************************************************************
*                                 Alert message                                 
*
* @param idx_alert    index of the alert
* @param message    Set the message that appears when alert occurs
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static void load_alert_message(uint8_t idx, char *alert_message_val)
{
    uint8_t bytes[EE_SIZE_ALERT_MESSAGE];

    bytes[63] = read_eeprom(map_alert_message_byte1[idx]);
    bytes[62] = read_eeprom(map_alert_message_byte2[idx]);
    bytes[61] = read_eeprom(map_alert_message_byte3[idx]);
    bytes[60] = read_eeprom(map_alert_message_byte4[idx]);
    bytes[59] = read_eeprom(map_alert_message_byte5[idx]);
    bytes[58] = read_eeprom(map_alert_message_byte6[idx]);
    bytes[57] = read_eeprom(map_alert_message_byte7[idx]);
    bytes[56] = read_eeprom(map_alert_message_byte8[idx]);
    bytes[55] = read_eeprom(map_alert_message_byte9[idx]);
    bytes[54] = read_eeprom(map_alert_message_byte10[idx]);
    bytes[53] = read_eeprom(map_alert_message_byte11[idx]);
    bytes[52] = read_eeprom(map_alert_message_byte12[idx]);
    bytes[51] = read_eeprom(map_alert_message_byte13[idx]);
    bytes[50] = read_eeprom(map_alert_message_byte14[idx]);
    bytes[49] = read_eeprom(map_alert_message_byte15[idx]);
    bytes[48] = read_eeprom(map_alert_message_byte16[idx]);
    bytes[47] = read_eeprom(map_alert_message_byte17[idx]);
    bytes[46] = read_eeprom(map_alert_message_byte18[idx]);
    bytes[45] = read_eeprom(map_alert_message_byte19[idx]);
    bytes[44] = read_eeprom(map_alert_message_byte20[idx]);
    bytes[43] = read_eeprom(map_alert_message_byte21[idx]);
    bytes[42] = read_eeprom(map_alert_message_byte22[idx]);
    bytes[41] = read_eeprom(map_alert_message_byte23[idx]);
    bytes[40] = read_eeprom(map_alert_message_byte24[idx]);
    bytes[39] = read_eeprom(map_alert_message_byte25[idx]);
    bytes[38] = read_eeprom(map_alert_message_byte26[idx]);
    bytes[37] = read_eeprom(map_alert_message_byte27[idx]);
    bytes[36] = read_eeprom(map_alert_message_byte28[idx]);
    bytes[35] = read_eeprom(map_alert_message_byte29[idx]);
    bytes[34] = read_eeprom(map_alert_message_byte30[idx]);
    bytes[33] = read_eeprom(map_alert_message_byte31[idx]);
    bytes[32] = read_eeprom(map_alert_message_byte32[idx]);
    bytes[31] = read_eeprom(map_alert_message_byte33[idx]);
    bytes[30] = read_eeprom(map_alert_message_byte34[idx]);
    bytes[29] = read_eeprom(map_alert_message_byte35[idx]);
    bytes[28] = read_eeprom(map_alert_message_byte36[idx]);
    bytes[27] = read_eeprom(map_alert_message_byte37[idx]);
    bytes[26] = read_eeprom(map_alert_message_byte38[idx]);
    bytes[25] = read_eeprom(map_alert_message_byte39[idx]);
    bytes[24] = read_eeprom(map_alert_message_byte40[idx]);
    bytes[23] = read_eeprom(map_alert_message_byte41[idx]);
    bytes[22] = read_eeprom(map_alert_message_byte42[idx]);
    bytes[21] = read_eeprom(map_alert_message_byte43[idx]);
    bytes[20] = read_eeprom(map_alert_message_byte44[idx]);
    bytes[19] = read_eeprom(map_alert_message_byte45[idx]);
    bytes[18] = read_eeprom(map_alert_message_byte46[idx]);
    bytes[17] = read_eeprom(map_alert_message_byte47[idx]);
    bytes[16] = read_eeprom(map_alert_message_byte48[idx]);
    bytes[15] = read_eeprom(map_alert_message_byte49[idx]);
    bytes[14] = read_eeprom(map_alert_message_byte50[idx]);
    bytes[13] = read_eeprom(map_alert_message_byte51[idx]);
    bytes[12] = read_eeprom(map_alert_message_byte52[idx]);
    bytes[11] = read_eeprom(map_alert_message_byte53[idx]);
    bytes[10] = read_eeprom(map_alert_message_byte54[idx]);
    bytes[9] = read_eeprom(map_alert_message_byte55[idx]);
    bytes[8] = read_eeprom(map_alert_message_byte56[idx]);
    bytes[7] = read_eeprom(map_alert_message_byte57[idx]);
    bytes[6] = read_eeprom(map_alert_message_byte58[idx]);
    bytes[5] = read_eeprom(map_alert_message_byte59[idx]);
    bytes[4] = read_eeprom(map_alert_message_byte60[idx]);
    bytes[3] = read_eeprom(map_alert_message_byte61[idx]);
    bytes[2] = read_eeprom(map_alert_message_byte62[idx]);
    bytes[1] = read_eeprom(map_alert_message_byte63[idx]);
    bytes[0] = read_eeprom(map_alert_message_byte64[idx]);

    memcpy(alert_message_val, bytes, EE_SIZE_ALERT_MESSAGE);
}

static void save_alert_message(uint8_t idx, char *alert_message)
{
    uint8_t bytes[EE_SIZE_ALERT_MESSAGE];

    memcpy(bytes, alert_message, EE_SIZE_ALERT_MESSAGE);

    write_eeprom(map_alert_message_byte1[idx], bytes[63]);
    write_eeprom(map_alert_message_byte2[idx], bytes[62]);
    write_eeprom(map_alert_message_byte3[idx], bytes[61]);
    write_eeprom(map_alert_message_byte4[idx], bytes[60]);
    write_eeprom(map_alert_message_byte5[idx], bytes[59]);
    write_eeprom(map_alert_message_byte6[idx], bytes[58]);
    write_eeprom(map_alert_message_byte7[idx], bytes[57]);
    write_eeprom(map_alert_message_byte8[idx], bytes[56]);
    write_eeprom(map_alert_message_byte9[idx], bytes[55]);
    write_eeprom(map_alert_message_byte10[idx], bytes[54]);
    write_eeprom(map_alert_message_byte11[idx], bytes[53]);
    write_eeprom(map_alert_message_byte12[idx], bytes[52]);
    write_eeprom(map_alert_message_byte13[idx], bytes[51]);
    write_eeprom(map_alert_message_byte14[idx], bytes[50]);
    write_eeprom(map_alert_message_byte15[idx], bytes[49]);
    write_eeprom(map_alert_message_byte16[idx], bytes[48]);
    write_eeprom(map_alert_message_byte17[idx], bytes[47]);
    write_eeprom(map_alert_message_byte18[idx], bytes[46]);
    write_eeprom(map_alert_message_byte19[idx], bytes[45]);
    write_eeprom(map_alert_message_byte20[idx], bytes[44]);
    write_eeprom(map_alert_message_byte21[idx], bytes[43]);
    write_eeprom(map_alert_message_byte22[idx], bytes[42]);
    write_eeprom(map_alert_message_byte23[idx], bytes[41]);
    write_eeprom(map_alert_message_byte24[idx], bytes[40]);
    write_eeprom(map_alert_message_byte25[idx], bytes[39]);
    write_eeprom(map_alert_message_byte26[idx], bytes[38]);
    write_eeprom(map_alert_message_byte27[idx], bytes[37]);
    write_eeprom(map_alert_message_byte28[idx], bytes[36]);
    write_eeprom(map_alert_message_byte29[idx], bytes[35]);
    write_eeprom(map_alert_message_byte30[idx], bytes[34]);
    write_eeprom(map_alert_message_byte31[idx], bytes[33]);
    write_eeprom(map_alert_message_byte32[idx], bytes[32]);
    write_eeprom(map_alert_message_byte33[idx], bytes[31]);
    write_eeprom(map_alert_message_byte34[idx], bytes[30]);
    write_eeprom(map_alert_message_byte35[idx], bytes[29]);
    write_eeprom(map_alert_message_byte36[idx], bytes[28]);
    write_eeprom(map_alert_message_byte37[idx], bytes[27]);
    write_eeprom(map_alert_message_byte38[idx], bytes[26]);
    write_eeprom(map_alert_message_byte39[idx], bytes[25]);
    write_eeprom(map_alert_message_byte40[idx], bytes[24]);
    write_eeprom(map_alert_message_byte41[idx], bytes[23]);
    write_eeprom(map_alert_message_byte42[idx], bytes[22]);
    write_eeprom(map_alert_message_byte43[idx], bytes[21]);
    write_eeprom(map_alert_message_byte44[idx], bytes[20]);
    write_eeprom(map_alert_message_byte45[idx], bytes[19]);
    write_eeprom(map_alert_message_byte46[idx], bytes[18]);
    write_eeprom(map_alert_message_byte47[idx], bytes[17]);
    write_eeprom(map_alert_message_byte48[idx], bytes[16]);
    write_eeprom(map_alert_message_byte49[idx], bytes[15]);
    write_eeprom(map_alert_message_byte50[idx], bytes[14]);
    write_eeprom(map_alert_message_byte51[idx], bytes[13]);
    write_eeprom(map_alert_message_byte52[idx], bytes[12]);
    write_eeprom(map_alert_message_byte53[idx], bytes[11]);
    write_eeprom(map_alert_message_byte54[idx], bytes[10]);
    write_eeprom(map_alert_message_byte55[idx], bytes[9]);
    write_eeprom(map_alert_message_byte56[idx], bytes[8]);
    write_eeprom(map_alert_message_byte57[idx], bytes[7]);
    write_eeprom(map_alert_message_byte58[idx], bytes[6]);
    write_eeprom(map_alert_message_byte59[idx], bytes[5]);
    write_eeprom(map_alert_message_byte60[idx], bytes[4]);
    write_eeprom(map_alert_message_byte61[idx], bytes[3]);
    write_eeprom(map_alert_message_byte62[idx], bytes[2]);
    write_eeprom(map_alert_message_byte63[idx], bytes[1]);
    write_eeprom(map_alert_message_byte64[idx], bytes[0]);
}

bool verify_alert_message(char* alert_message)
{
    return 1; // TODO - String checking
}

void get_alert_message(uint8_t idx, char* alert_message)
{
    memcpy(alert_message, settings_alert_message[idx], ALERT_MESSAGE_LEN);
}

// Set the Alert message
bool set_alert_message(uint8_t idx, char* alert_message, bool save)
{
    // Verify the Alert message value is valid
    if (!verify_alert_message(alert_message))
        return false;

    // Check to see if the Alert message EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        // Reload the current setting saved in EEPROM
        load_alert_message(idx, settings_alert_message[idx]);

        if (settings_alert_message[idx] != alert_message)
        {
            save_alert_message(idx, alert_message);
        }
    }

    memcpy(settings_alert_message[idx], alert_message, ALERT_MESSAGE_LEN);

    return 1;
}


/********************************************************************************
*                                Comparison type                                
*
* @param idx_alert    index of the alert
* @param compare    Configure the comparison used for the realtime value and alert threshold
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
const char *alert_comparison_string[] = {
    "Less Than",
    "Less Than Or Equal To",
    "Greater Than",
    "Greater Than Or Equal To",
    "Equal",
    "Not Equal"
};

static void load_alert_compare(uint8_t idx, ALERT_COMPARISON *alert_compare_val)
{
    uint8_t bytes[EE_SIZE_ALERT_COMPARE];

    bytes[0] = read_eeprom(map_alert_compare_byte1[idx]);

    memcpy(alert_compare_val, bytes, EE_SIZE_ALERT_COMPARE);
}

static void save_alert_compare(uint8_t idx, ALERT_COMPARISON *alert_compare)
{
    uint8_t bytes[EE_SIZE_ALERT_COMPARE];

    memcpy(bytes, alert_compare, EE_SIZE_ALERT_COMPARE);

    write_eeprom(map_alert_compare_byte1[idx], bytes[0]);
}

bool verify_alert_compare(ALERT_COMPARISON alert_compare)
{
    if (alert_compare >= ALERT_COMPARISON_RESERVED)
        return 0;
    else
        return 1;
}

ALERT_COMPARISON get_alert_compare(uint8_t idx)
{
    // Verify the Comparison type value is valid
    if (!verify_alert_compare(settings_alert_compare[idx]))
        return DEFAULT_ALERT_COMPARE;

    return settings_alert_compare[idx];
}

// Set the Comparison type
bool set_alert_compare(uint8_t idx, ALERT_COMPARISON alert_compare, bool save)
{
    // Verify the Comparison type value is valid
    if (!verify_alert_compare(alert_compare))
        return false;

    // Check to see if the Comparison type EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        // Reload the current setting saved in EEPROM
        load_alert_compare(idx, &settings_alert_compare[idx]);

        if (settings_alert_compare[idx] != alert_compare)
        {
            save_alert_compare(idx, &alert_compare);
        }
    }

    settings_alert_compare[idx] = alert_compare;

    return 1;
}

ALERT_COMPARISON get_alert_compare_from_string(const char *str)
{
    if(strcmp(str, "Less Than") == 0) return ALERT_COMPARISON_LESS_THAN;
    if(strcmp(str, "Less Than Or Equal To") == 0) return ALERT_COMPARISON_LESS_THAN_OR_EQUAL_TO;
    if(strcmp(str, "Greater Than") == 0) return ALERT_COMPARISON_GREATER_THAN;
    if(strcmp(str, "Greater Than Or Equal To") == 0) return ALERT_COMPARISON_GREATER_THAN_OR_EQUAL_TO;
    if(strcmp(str, "Equal") == 0) return ALERT_COMPARISON_EQUAL;
    if(strcmp(str, "Not Equal") == 0) return ALERT_COMPARISON_NOT_EQUAL;
    return ALERT_COMPARISON_RESERVED;
}



/********************************************************************************
*                            Dynamic gauge threshold                            
*
* @param idx_alert    index of the alert
* @param threshold    Comparison value of the dynamic gauge
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static void load_alert_threshold(uint8_t idx, float *alert_threshold_val)
{
    uint8_t bytes[EE_SIZE_ALERT_THRESHOLD];

    bytes[3] = read_eeprom(map_alert_threshold_byte1[idx]);
    bytes[2] = read_eeprom(map_alert_threshold_byte2[idx]);
    bytes[1] = read_eeprom(map_alert_threshold_byte3[idx]);
    bytes[0] = read_eeprom(map_alert_threshold_byte4[idx]);

    memcpy(alert_threshold_val, bytes, EE_SIZE_ALERT_THRESHOLD);
}

static void save_alert_threshold(uint8_t idx, float *alert_threshold)
{
    uint8_t bytes[EE_SIZE_ALERT_THRESHOLD];

    memcpy(bytes, alert_threshold, EE_SIZE_ALERT_THRESHOLD);

    write_eeprom(map_alert_threshold_byte1[idx], bytes[3]);
    write_eeprom(map_alert_threshold_byte2[idx], bytes[2]);
    write_eeprom(map_alert_threshold_byte3[idx], bytes[1]);
    write_eeprom(map_alert_threshold_byte4[idx], bytes[0]);
}

bool verify_alert_threshold(float alert_threshold)
{
    if (alert_threshold < -100000)
        return 0;

    if (alert_threshold > 100000)
        return 0;

    else
        return 1;
}

float get_alert_threshold(uint8_t idx)
{
    // Verify the Dynamic gauge threshold value is valid
    if (!verify_alert_threshold(settings_alert_threshold[idx]))
        return DEFAULT_ALERT_THRESHOLD;

    return settings_alert_threshold[idx];
}

// Set the Dynamic gauge threshold
bool set_alert_threshold(uint8_t idx, float alert_threshold, bool save)
{
    // Verify the Dynamic gauge threshold value is valid
    if (!verify_alert_threshold(alert_threshold))
        return false;

    // Check to see if the Dynamic gauge threshold EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        // Reload the current setting saved in EEPROM
        load_alert_threshold(idx, &settings_alert_threshold[idx]);

        if (settings_alert_threshold[idx] != alert_threshold)
        {
            save_alert_threshold(idx, &alert_threshold);
        }
    }

    settings_alert_threshold[idx] = alert_threshold;

    return 1;
}


/********************************************************************************
*                                 Dynamic enable                                
*
* @param idx_dynamic    index of the dynamic
* @param enable    Enable or disable view by index
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
const char *dynamic_state_string[] = {
    "Disabled",
    "Enabled"
};

static void load_dynamic_enable(uint8_t idx, DYNAMIC_STATE *dynamic_enable_val)
{
    uint8_t bytes[EE_SIZE_DYNAMIC_ENABLE];

    bytes[0] = read_eeprom(map_dynamic_enable_byte1[idx]);

    memcpy(dynamic_enable_val, bytes, EE_SIZE_DYNAMIC_ENABLE);
}

static void save_dynamic_enable(uint8_t idx, DYNAMIC_STATE *dynamic_enable)
{
    uint8_t bytes[EE_SIZE_DYNAMIC_ENABLE];

    memcpy(bytes, dynamic_enable, EE_SIZE_DYNAMIC_ENABLE);

    write_eeprom(map_dynamic_enable_byte1[idx], bytes[0]);
}

bool verify_dynamic_enable(DYNAMIC_STATE dynamic_enable)
{
    if (dynamic_enable >= DYNAMIC_STATE_RESERVED)
        return 0;
    else
        return 1;
}

DYNAMIC_STATE get_dynamic_enable(uint8_t idx)
{
    // Verify the Dynamic enable value is valid
    if (!verify_dynamic_enable(settings_dynamic_enable[idx]))
        return DEFAULT_DYNAMIC_ENABLE;

    return settings_dynamic_enable[idx];
}

// Set the Dynamic enable
bool set_dynamic_enable(uint8_t idx, DYNAMIC_STATE dynamic_enable, bool save)
{
    // Verify the Dynamic enable value is valid
    if (!verify_dynamic_enable(dynamic_enable))
        return false;

    // Check to see if the Dynamic enable EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        // Reload the current setting saved in EEPROM
        load_dynamic_enable(idx, &settings_dynamic_enable[idx]);

        if (settings_dynamic_enable[idx] != dynamic_enable)
        {
            save_dynamic_enable(idx, &dynamic_enable);
        }
    }

    settings_dynamic_enable[idx] = dynamic_enable;

    return 1;
}

DYNAMIC_STATE get_dynamic_enable_from_string(const char *str)
{
    if(strcmp(str, "Disabled") == 0) return DYNAMIC_STATE_DISABLED;
    if(strcmp(str, "Enabled") == 0) return DYNAMIC_STATE_ENABLED;
    return DYNAMIC_STATE_RESERVED;
}



/********************************************************************************
*                                    Priority                                   
*
* @param idx_dynamic    index of the dynamic
* @param priority    Priority of the dynamic gauges, if both gauges comparisons are met then highest priority wins
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
const char *dynamic_priority_string[] = {
    "Low",
    "Medium",
    "High"
};

static void load_dynamic_priority(uint8_t idx, DYNAMIC_PRIORITY *dynamic_priority_val)
{
    uint8_t bytes[EE_SIZE_DYNAMIC_PRIORITY];

    bytes[0] = read_eeprom(map_dynamic_priority_byte1[idx]);

    memcpy(dynamic_priority_val, bytes, EE_SIZE_DYNAMIC_PRIORITY);
}

static void save_dynamic_priority(uint8_t idx, DYNAMIC_PRIORITY *dynamic_priority)
{
    uint8_t bytes[EE_SIZE_DYNAMIC_PRIORITY];

    memcpy(bytes, dynamic_priority, EE_SIZE_DYNAMIC_PRIORITY);

    write_eeprom(map_dynamic_priority_byte1[idx], bytes[0]);
}

bool verify_dynamic_priority(DYNAMIC_PRIORITY dynamic_priority)
{
    if (dynamic_priority >= DYNAMIC_PRIORITY_RESERVED)
        return 0;
    else
        return 1;
}

DYNAMIC_PRIORITY get_dynamic_priority(uint8_t idx)
{
    // Verify the Priority value is valid
    if (!verify_dynamic_priority(settings_dynamic_priority[idx]))
        return DEFAULT_DYNAMIC_PRIORITY;

    return settings_dynamic_priority[idx];
}

// Set the Priority
bool set_dynamic_priority(uint8_t idx, DYNAMIC_PRIORITY dynamic_priority, bool save)
{
    // Verify the Priority value is valid
    if (!verify_dynamic_priority(dynamic_priority))
        return false;

    // Check to see if the Priority EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        // Reload the current setting saved in EEPROM
        load_dynamic_priority(idx, &settings_dynamic_priority[idx]);

        if (settings_dynamic_priority[idx] != dynamic_priority)
        {
            save_dynamic_priority(idx, &dynamic_priority);
        }
    }

    settings_dynamic_priority[idx] = dynamic_priority;

    return 1;
}

DYNAMIC_PRIORITY get_dynamic_priority_from_string(const char *str)
{
    if(strcmp(str, "Low") == 0) return DYNAMIC_PRIORITY_LOW;
    if(strcmp(str, "Medium") == 0) return DYNAMIC_PRIORITY_MEDIUM;
    if(strcmp(str, "High") == 0) return DYNAMIC_PRIORITY_HIGH;
    return DYNAMIC_PRIORITY_RESERVED;
}



/********************************************************************************
*                                Comparison type                                
*
* @param idx_dynamic    index of the dynamic
* @param compare    Configure the comparison used for the realtime value and alert threshold
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
const char *dynamic_comparison_string[] = {
    "Less Than",
    "Less Than Or Equal To",
    "Greater Than",
    "Greater Than Or Equal To",
    "Equal",
    "Not Equal"
};

static void load_dynamic_compare(uint8_t idx, DYNAMIC_COMPARISON *dynamic_compare_val)
{
    uint8_t bytes[EE_SIZE_DYNAMIC_COMPARE];

    bytes[0] = read_eeprom(map_dynamic_compare_byte1[idx]);

    memcpy(dynamic_compare_val, bytes, EE_SIZE_DYNAMIC_COMPARE);
}

static void save_dynamic_compare(uint8_t idx, DYNAMIC_COMPARISON *dynamic_compare)
{
    uint8_t bytes[EE_SIZE_DYNAMIC_COMPARE];

    memcpy(bytes, dynamic_compare, EE_SIZE_DYNAMIC_COMPARE);

    write_eeprom(map_dynamic_compare_byte1[idx], bytes[0]);
}

bool verify_dynamic_compare(DYNAMIC_COMPARISON dynamic_compare)
{
    if (dynamic_compare >= DYNAMIC_COMPARISON_RESERVED)
        return 0;
    else
        return 1;
}

DYNAMIC_COMPARISON get_dynamic_compare(uint8_t idx)
{
    // Verify the Comparison type value is valid
    if (!verify_dynamic_compare(settings_dynamic_compare[idx]))
        return DEFAULT_DYNAMIC_COMPARE;

    return settings_dynamic_compare[idx];
}

// Set the Comparison type
bool set_dynamic_compare(uint8_t idx, DYNAMIC_COMPARISON dynamic_compare, bool save)
{
    // Verify the Comparison type value is valid
    if (!verify_dynamic_compare(dynamic_compare))
        return false;

    // Check to see if the Comparison type EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        // Reload the current setting saved in EEPROM
        load_dynamic_compare(idx, &settings_dynamic_compare[idx]);

        if (settings_dynamic_compare[idx] != dynamic_compare)
        {
            save_dynamic_compare(idx, &dynamic_compare);
        }
    }

    settings_dynamic_compare[idx] = dynamic_compare;

    return 1;
}

DYNAMIC_COMPARISON get_dynamic_compare_from_string(const char *str)
{
    if(strcmp(str, "Less Than") == 0) return DYNAMIC_COMPARISON_LESS_THAN;
    if(strcmp(str, "Less Than Or Equal To") == 0) return DYNAMIC_COMPARISON_LESS_THAN_OR_EQUAL_TO;
    if(strcmp(str, "Greater Than") == 0) return DYNAMIC_COMPARISON_GREATER_THAN;
    if(strcmp(str, "Greater Than Or Equal To") == 0) return DYNAMIC_COMPARISON_GREATER_THAN_OR_EQUAL_TO;
    if(strcmp(str, "Equal") == 0) return DYNAMIC_COMPARISON_EQUAL;
    if(strcmp(str, "Not Equal") == 0) return DYNAMIC_COMPARISON_NOT_EQUAL;
    return DYNAMIC_COMPARISON_RESERVED;
}



/********************************************************************************
*                            Dynamic gauge threshold                            
*
* @param idx_dynamic    index of the dynamic
* @param Threshold    Comparison value of the dynamic gauge
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static void load_dynamic_threshold(uint8_t idx, float *dynamic_threshold_val)
{
    uint8_t bytes[EE_SIZE_DYNAMIC_THRESHOLD];

    bytes[3] = read_eeprom(map_dynamic_threshold_byte1[idx]);
    bytes[2] = read_eeprom(map_dynamic_threshold_byte2[idx]);
    bytes[1] = read_eeprom(map_dynamic_threshold_byte3[idx]);
    bytes[0] = read_eeprom(map_dynamic_threshold_byte4[idx]);

    memcpy(dynamic_threshold_val, bytes, EE_SIZE_DYNAMIC_THRESHOLD);
}

static void save_dynamic_threshold(uint8_t idx, float *dynamic_threshold)
{
    uint8_t bytes[EE_SIZE_DYNAMIC_THRESHOLD];

    memcpy(bytes, dynamic_threshold, EE_SIZE_DYNAMIC_THRESHOLD);

    write_eeprom(map_dynamic_threshold_byte1[idx], bytes[3]);
    write_eeprom(map_dynamic_threshold_byte2[idx], bytes[2]);
    write_eeprom(map_dynamic_threshold_byte3[idx], bytes[1]);
    write_eeprom(map_dynamic_threshold_byte4[idx], bytes[0]);
}

bool verify_dynamic_threshold(float dynamic_threshold)
{
    if (dynamic_threshold < -100000)
        return 0;

    if (dynamic_threshold > 100000)
        return 0;

    else
        return 1;
}

float get_dynamic_threshold(uint8_t idx)
{
    // Verify the Dynamic gauge threshold value is valid
    if (!verify_dynamic_threshold(settings_dynamic_threshold[idx]))
        return DEFAULT_DYNAMIC_THRESHOLD;

    return settings_dynamic_threshold[idx];
}

// Set the Dynamic gauge threshold
bool set_dynamic_threshold(uint8_t idx, float dynamic_threshold, bool save)
{
    // Verify the Dynamic gauge threshold value is valid
    if (!verify_dynamic_threshold(dynamic_threshold))
        return false;

    // Check to see if the Dynamic gauge threshold EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        // Reload the current setting saved in EEPROM
        load_dynamic_threshold(idx, &settings_dynamic_threshold[idx]);

        if (settings_dynamic_threshold[idx] != dynamic_threshold)
        {
            save_dynamic_threshold(idx, &dynamic_threshold);
        }
    }

    settings_dynamic_threshold[idx] = dynamic_threshold;

    return 1;
}


/********************************************************************************
*                                   View index                                  
*
* @param idx_dynamic    index of the dynamic
* @param Index    Set which view should be enabled if the dynamic event is true
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static void load_dynamic_index(uint8_t idx, uint8_t *dynamic_index_val)
{
    uint8_t bytes[EE_SIZE_DYNAMIC_INDEX];

    bytes[0] = read_eeprom(map_dynamic_index_byte1[idx]);

    memcpy(dynamic_index_val, bytes, EE_SIZE_DYNAMIC_INDEX);
}

static void save_dynamic_index(uint8_t idx, uint8_t *dynamic_index)
{
    uint8_t bytes[EE_SIZE_DYNAMIC_INDEX];

    memcpy(bytes, dynamic_index, EE_SIZE_DYNAMIC_INDEX);

    write_eeprom(map_dynamic_index_byte1[idx], bytes[0]);
}

bool verify_dynamic_index(uint8_t dynamic_index)
{
    if (dynamic_index > MAX_VIEWS)
        return 0;

    else
        return 1;
}

uint8_t get_dynamic_index(uint8_t idx)
{
    // Verify the View index value is valid
    if (!verify_dynamic_index(settings_dynamic_index[idx]))
        return DEFAULT_DYNAMIC_INDEX;

    return settings_dynamic_index[idx];
}

// Set the View index
bool set_dynamic_index(uint8_t idx, uint8_t dynamic_index, bool save)
{
    // Verify the View index value is valid
    if (!verify_dynamic_index(dynamic_index))
        return false;

    // Check to see if the View index EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        // Reload the current setting saved in EEPROM
        load_dynamic_index(idx, &settings_dynamic_index[idx]);

        if (settings_dynamic_index[idx] != dynamic_index)
        {
            save_dynamic_index(idx, &dynamic_index);
        }
    }

    settings_dynamic_index[idx] = dynamic_index;

    return 1;
}


/********************************************************************************
*                       PID assigned to the dynamic gauge                       
*
* @param idx_dynamic    index of the dynamic
* @param pid    Set the dynamic PID by dynamic index
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static void load_dynamic_pid(uint8_t idx, uint32_t *dynamic_pid_val)
{
    uint8_t bytes[EE_SIZE_DYNAMIC_PID];

    bytes[3] = read_eeprom(map_dynamic_pid_byte1[idx]);
    bytes[2] = read_eeprom(map_dynamic_pid_byte2[idx]);
    bytes[1] = read_eeprom(map_dynamic_pid_byte3[idx]);
    bytes[0] = read_eeprom(map_dynamic_pid_byte4[idx]);

    memcpy(dynamic_pid_val, bytes, EE_SIZE_DYNAMIC_PID);
}

static void save_dynamic_pid(uint8_t idx, uint32_t *dynamic_pid)
{
    uint8_t bytes[EE_SIZE_DYNAMIC_PID];

    memcpy(bytes, dynamic_pid, EE_SIZE_DYNAMIC_PID);

    write_eeprom(map_dynamic_pid_byte1[idx], bytes[3]);
    write_eeprom(map_dynamic_pid_byte2[idx], bytes[2]);
    write_eeprom(map_dynamic_pid_byte3[idx], bytes[1]);
    write_eeprom(map_dynamic_pid_byte4[idx], bytes[0]);
}

bool verify_dynamic_pid(uint32_t dynamic_pid)
{
    if (dynamic_pid < 1)
        return 0;

    if (dynamic_pid > 16777215)
        return 0;

    else
        return 1;
}

uint32_t get_dynamic_pid(uint8_t idx)
{
    // Verify the PID assigned to the dynamic gauge value is valid
    if (!verify_dynamic_pid(settings_dynamic_pid[idx]))
        return DEFAULT_DYNAMIC_PID;

    return settings_dynamic_pid[idx];
}

// Set the PID assigned to the dynamic gauge
bool set_dynamic_pid(uint8_t idx, uint32_t dynamic_pid, bool save)
{
    // Verify the PID assigned to the dynamic gauge value is valid
    if (!verify_dynamic_pid(dynamic_pid))
        return false;

    // Check to see if the PID assigned to the dynamic gauge EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        // Reload the current setting saved in EEPROM
        load_dynamic_pid(idx, &settings_dynamic_pid[idx]);

        if (settings_dynamic_pid[idx] != dynamic_pid)
        {
            save_dynamic_pid(idx, &dynamic_pid);
        }
    }

    settings_dynamic_pid[idx] = dynamic_pid;

    return 1;
}


/********************************************************************************
*                       PID units assigned to the dynamic                       
*
* @param idx_dynamic    index of the dynamic
* @param units    Set the PID units by dynamic index
* @param save    Set true to save to the EEPROM, otherwise value is non-volatile
*
********************************************************************************/
static void load_dynamic_units(uint8_t idx, PID_UNITS *dynamic_units_val)
{
    uint8_t bytes[EE_SIZE_DYNAMIC_UNITS];

    bytes[0] = read_eeprom(map_dynamic_units_byte1[idx]);

    memcpy(dynamic_units_val, bytes, EE_SIZE_DYNAMIC_UNITS);
}

static void save_dynamic_units(uint8_t idx, PID_UNITS *dynamic_units)
{
    uint8_t bytes[EE_SIZE_DYNAMIC_UNITS];

    memcpy(bytes, dynamic_units, EE_SIZE_DYNAMIC_UNITS);

    write_eeprom(map_dynamic_units_byte1[idx], bytes[0]);
}

bool verify_dynamic_units(PID_UNITS dynamic_units)
{
    if (dynamic_units < 1)
        return 0;

    if (dynamic_units > 255)
        return 0;

    else
        return 1;
}

PID_UNITS get_dynamic_units(uint8_t idx)
{
    // Verify the PID units assigned to the dynamic value is valid
    if (!verify_dynamic_units(settings_dynamic_units[idx]))
        return DEFAULT_DYNAMIC_UNITS;

    return settings_dynamic_units[idx];
}

// Set the PID units assigned to the dynamic
bool set_dynamic_units(uint8_t idx, PID_UNITS dynamic_units, bool save)
{
    // Verify the PID units assigned to the dynamic value is valid
    if (!verify_dynamic_units(dynamic_units))
        return false;

    // Check to see if the PID units assigned to the dynamic EEPROM value needs to be
    // updated if immediate save is set
    if (save)
    {
        // Reload the current setting saved in EEPROM
        load_dynamic_units(idx, &settings_dynamic_units[idx]);

        if (settings_dynamic_units[idx] != dynamic_units)
        {
            save_dynamic_units(idx, &dynamic_units);
        }
    }

    settings_dynamic_units[idx] = dynamic_units;

    return 1;
}
